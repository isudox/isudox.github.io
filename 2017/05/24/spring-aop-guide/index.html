<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Spring AOP 那些事儿</title>
  
  <meta name="description" content="AOP 即 Aspect-Oriented Programming，面向切面编程，是对 OOP 编程思想的补充。OOP 核心是继承、封装、多态，是实现 OOP 模块化的基础。当 OOP 达到一定规模后，对">
  <meta name="author" content="isudox">
  
  <link href="https://isudox.com/style.css" rel="stylesheet">
  <link href="https://isudox.com/custom.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="https://isudox.com/apple-touch-icon.png">
  <link rel="icon" href="https://isudox.com/favicon.ico">
  <meta name="generator" content="Hugo 0.91.2" />
  
  
</head>

<body class="single">
  <script>
    setTheme();
  </script>
  <header class="header">
    <nav class="nav">
      <p class="logo"><a href="https://isudox.com/">I sudo X</a></p>
      <ul class="menu">
        <li>
          <a class="menu-list-link" href="/posts/">文档</a>
          
        </li>
        <li>
          <a class="menu-list-link" href="/tags/">标签</a>
          
        </li>
        <li>
          <a class="menu-list-link" href="/about/">关于</a>
          
        </li>
      </ul>
    </nav>
  </header>
  <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">Spring AOP 那些事儿</h1>
    <div class="post-meta">2017/05/24</div>
  </header>
  <div class="post-content"><p>AOP 即 Aspect-Oriented Programming，<strong>面向切面编程</strong>，是对 OOP 编程思想的补充。OOP 核心是继承、封装、多态，是实现 OOP 模块化的基础。当 OOP 达到一定规模后，对于遍布各处的横向代码的处理就开始捉襟见肘，而 AOP 正好弥补了这个不足。</p>
<!-- more -->
<h2 id="引入-aop">引入 AOP</h2>
<p>下图是很常见的编程场景──</p>
<p><img src="https://o70e8d1kb.qnssl.com/redundant_code.png" alt="redundant code"></p>
<p>我们经常会遇到需要在多个方法中实现相同的一部分功能，面向过程的办法就是像图示在每个方法里都复制粘贴相同的一段代码，但是如果要改动就要改动 N 处代码。在有了 OOP 思想后，我们就进阶了一大步，可以将相同的代码段抽离出来，避免了到处改动的问题。</p>
<p><img src="https://o70e8d1kb.qnssl.com/clean_code.png" alt="clean code"></p>
<p>一般像上图去实现代码就能应付大多数场景了。但随着软件规模的升级，有些问题就开始凸显了。首先共同功能的实现需要在各个方法中显示的去调用；其次，共同功能的控制权分散在代码各处；再次，对共同功能的依赖加重了类之间的耦合，降低了可重用性，如果共同功能并非各个方法的核心功能，那么就不应该耦合进各个对象中。AOP 则可以解决这些问题。</p>
<p>AOP 把系统功能分为两部分：<strong>核心关注点</strong>，<strong>横切关注点</strong>。核心关注点是代码的主要逻辑；横切进多个模块，但不是模块主要逻辑的就是横切关注点。不是简单的把公共模块抽离出来，而是把那些与具体业务无关的，却为业务模块所共同调用的逻辑或责任封装起来，减少冗余代码，降低模块间耦合度，提升可维护性。</p>
<h2 id="基本概念">基本概念</h2>
<h3 id="什么是-aop">什么是 AOP</h3>
<p>《Sping 实战》中对 AOP 有一段非常形象的描述──</p>
<blockquote>
<p>每家每户都需要用电，电力公司会安装电表会记录用电量，会派员工查电表。但是如果没有电表也没有人来查看用电量，相信大多数家庭都不会去记录电量并缴费，因为这不是家庭重点关注的问题。软件开发中，类似记录用电量这种散布于应用中多处的功能被称为<strong>横切关注点</strong>（cross-cutting concern），从概念上是与应用的业务逻辑相分离的（但往往会直接嵌入到业务逻辑中）。把横切关注点与业务逻辑相分离正是 AOP 所要解决的问题。</p>
</blockquote>
<p>知道 AOP 大致是做什么的后，再来了解下 AOP 的专用术语：</p>
<ul>
<li>切面 Aspect：横切关注点模块化的类；</li>
<li>连接点 Join point：程序的执行点，比如方法的执行，或者异常的处理。在 Spring AOP 中，连接点总是表示方法执行；</li>
<li>通知 Advice：切面在某个具体的连接点上执行的动作。且可以定义动作执行的时机，比如 <code>around</code>、<code>before</code>、<code>after</code> 等。包括 Spring 在内的许多 AOP 框架，都会把通知模块化成拦截器，围绕连接点构建拦截链；</li>
<li>切点 Poincut：匹配通知所要执行的一个或多个连接点。通常明确指定或者使用正则表达式匹配类名.方法。</li>
<li>引入 Introduction：即向已有的类添加新方法或属性。Spring AOP 允许向被通知的类添加新的接口（和其实现）。</li>
<li>目标对象 Target objection：被一个或多个切面通知的类。因为在 Spring 中，AOP 是通过运行时代理实现的，所以目标对象总是代理对象。</li>
<li>AOP 代理：由 AOP 框架创建的为实现 aspect 的对象，在 Spring 中，AOP 代理是 JDK 动态代理或 CGLIB 代理。</li>
<li>织入 Weaving：把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。织入可以在对象生命周期的编译期、类加载期、运行期完成。Spring AOP 因为采用动态代理，所以是在<strong>运行期</strong>完成织入。</li>
</ul>
<h3 id="代码演示">代码演示</h3>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#268bd2">@Component</span>
<span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">PrinterServiceImpl</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">PrinterService</span> {

    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">run</span>(<span style="color:#268bd2">String</span> <span style="color:#268bd2">message</span>) {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;Your message: &#34;</span> + <span style="color:#268bd2">message</span>);
    }
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// 日志切面
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#268bd2">@Aspect</span>
<span style="color:#268bd2">@Component</span>
<span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">LogAspect</span> {

    <span style="color:#268bd2">@AfterReturning</span>(<span style="color:#268bd2">pointcut</span> = <span style="color:#2aa198">&#34;execution(* com.isudox.service.impl.*.*(..))&#34;</span>)
    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">log</span>() {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;Job completed time: &#34;</span> + <span style="color:#859900">new</span> <span style="color:#268bd2">Date</span>());
    }
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// 事物切面
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#268bd2">@Aspect</span>
<span style="color:#268bd2">@Component</span>
<span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">TransactionAspect</span> {

    <span style="color:#268bd2">@Around</span>(<span style="color:#2aa198">&#34;execution(* com.isudox.service.impl.*.*(..))&#34;</span>)
    <span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">transact</span>(<span style="color:#268bd2">ProceedingJoinPoint</span> <span style="color:#268bd2">joinPoint</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">Throwable</span> {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;----Transaction begins----&#34;</span>);
        <span style="color:#268bd2">Object</span> <span style="color:#268bd2">result</span> = <span style="color:#268bd2">joinPoint</span>.<span style="color:#268bd2">proceed</span>();
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;----Transaction end----&#34;</span>);
        <span style="color:#859900">return</span> <span style="color:#268bd2">result</span>;
    }
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#93a1a1;font-style:italic">&lt;!-- spring-aop-config.xml --&gt;</span>
<span style="color:#268bd2;font-weight:bold">&lt;bean</span> <span style="color:#268bd2">class=</span><span style="color:#2aa198">&#34;org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator&#34;</span><span style="color:#268bd2;font-weight:bold">/&gt;</span>

<span style="color:#268bd2;font-weight:bold">&lt;context:component-scan</span> <span style="color:#268bd2">base-package=</span><span style="color:#2aa198">&#34;com.isudox&#34;</span><span style="color:#268bd2;font-weight:bold">/&gt;</span>
<span style="color:#268bd2;font-weight:bold">&lt;aop:aspectj-autoproxy/&gt;</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// Main 方法
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">App</span> {
    <span style="color:#859900">public</span> <span style="color:#859900">static</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">main</span>(<span style="color:#268bd2">String</span>[] <span style="color:#268bd2">args</span>) {
        <span style="color:#268bd2">ApplicationContext</span> <span style="color:#268bd2">ctx</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ClassPathXmlApplicationContext</span>(<span style="color:#2aa198">&#34;spring-aop-config.xml&#34;</span>);
        <span style="color:#268bd2">PrinterService</span> <span style="color:#268bd2">printer</span> = <span style="color:#268bd2">ctx</span>.<span style="color:#268bd2">getBean</span>(<span style="color:#2aa198">&#34;printerServiceImpl&#34;</span>, <span style="color:#268bd2">PrinterService</span>.<span style="color:#268bd2">class</span>);
        <span style="color:#268bd2">printer</span>.<span style="color:#268bd2">run</span>(<span style="color:#2aa198">&#34;Hello AOP&#34;</span>);
    }
}
<span style="color:#93a1a1;font-style:italic">// ----Transaction begins----
</span><span style="color:#93a1a1;font-style:italic">// Your message: Hello AOP
</span><span style="color:#93a1a1;font-style:italic">// ----Transaction end----
</span><span style="color:#93a1a1;font-style:italic">// Job completed time: Thu Jun 01 16:27:37 CST 2017
</span></code></pre></div><h2 id="代理模式">代理模式</h2>
<p>AOP 有多种实现方案，比如 <a href="http://www.eclipse.org/aspectj/">AspectJ</a> 和 Spring AOP。前者需要安装 AspectJ 扩展库，在编译器生成 AOP 代理类，后者则是在运行时动态生成代理类。总之，AOP 的实现是基于代理模式，所以先简单介绍下这种经典的设计模式。</p>
<blockquote>
<p>通过在代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。如下图所示，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean。当代理拦截到方法调用时，在调用目标 bean 方法之前，会执行切面逻辑。</p>
</blockquote>
<p><img src="https://o70e8d1kb.qnssl.com/aop-proxy.png" alt="aop proxy model"></p>
<p>Spring AOP 的实现本质上是采用了代理模式。</p>
<blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。──GoF《设计模式》</p>
</blockquote>
<p>通俗的解释下代理模式，比如以前玩魔兽世界，如果华南区玩家直接玩华北区的服务器延迟会很高，于是就有了各种游戏代理服务器，通过走代理直连游戏服务器可以有效缓解高延迟问题，还有 FQ 代理也是同样的道理。运用代理模式的目的是<strong>对其他对象提供一种代理以控制对这个对象引用的访问</strong>，这样设计的好处是，可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。</p>
<p>代理模式包含 4 种角色，参考如下 UML 图：</p>
<ul>
<li>主题接口：代理类和真实对象所实现的共同接口；</li>
<li>真实对象：被代理的对象，即实际引用的对象；</li>
<li>代理对象：封装了真实对象的代理类，并提供与真实对象相同的接口以便随时代替真实对象，同时可以对真实对象的操作进行加强；</li>
<li>客户端：代理对象的调用者；</li>
</ul>
<p><img src="https://o70e8d1kb.qnssl.com/proxy-uml.png" alt="代理模式 UML"></p>
<p>根据代理类的生成时期，可以分为静态代理和动态代理，静态代理是在编译期生成代理类的 <code>.class</code> 文件，动态代理是在运行时通过反射动态生成代理类。</p>
<h3 id="静态代理">静态代理</h3>
<p>参考 UML 图，我们可以用 Java 写一个简单的静态代理：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// Manager 接口
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">interface</span> <span style="color:#cb4b16">Manager</span> {

    <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">handle</span>(<span style="color:#268bd2">String</span> <span style="color:#268bd2">param</span>);

}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// 具体的 Manager 实现
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">DepartmentManager</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">Manager</span> {

    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">handle</span>(<span style="color:#268bd2">String</span> <span style="color:#268bd2">param</span>) {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;Today Plan: &#34;</span> + <span style="color:#268bd2">param</span>);
    }
    
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// Manger 代理类
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">ManagerProxy</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">Manager</span> {

    <span style="color:#859900">private</span> <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span>;

    <span style="color:#859900">public</span> <span style="color:#268bd2">ManagerProxy</span>(<span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span>) {
        <span style="color:#859900">this</span>.<span style="color:#268bd2">manager</span> = <span style="color:#268bd2">manager</span>;
    }

    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">handle</span>(<span style="color:#268bd2">String</span> <span style="color:#268bd2">param</span>) {
        <span style="color:#859900">this</span>.<span style="color:#268bd2">manager</span>.<span style="color:#268bd2">handle</span>(<span style="color:#268bd2">param</span>);
    }

}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// 静态代理测试
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">ManagerProxyTest</span> {

    <span style="color:#268bd2">@Test</span>
    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">handle</span>() <span style="color:#859900">throws</span> <span style="color:#268bd2">Exception</span> {
        <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">DepartmentManager</span>();
        <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">proxy</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">ManagerProxy</span>(<span style="color:#268bd2">manager</span>);
        <span style="color:#268bd2">proxy</span>.<span style="color:#268bd2">handle</span>(<span style="color:#2aa198">&#34;Monthly Review&#34;</span>);
    }
    <span style="color:#93a1a1;font-style:italic">// ----console output:-----
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// Today Plan: Monthly Review
</span><span style="color:#93a1a1;font-style:italic"></span>}
</code></pre></div><p>上面的例子演示了代理模式的一个基本实现，不过有人可能会产生疑问，如果只是简单地让 Department Manager 去做一件事，为什么要费劲创建一个代理类去完成，这不是舍近求远吗？前面讲到了，代理模式的目的是为了控制对目标对象的引用，也就是说，如果对目标对象的需求有所变动，遵循开闭原则不应该直接修改目标对象的代码，通过代理类就能不侵入的实现。以上面的代码为例，如果 Department Manager 需要在制定今日任务前输出 Manger 的职位，在制定任务后输出日期，在代理模式下，只需要对 Proxy 略微做修改即可改变真实对象引用的行为。修改后的代码如下──</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">ManagerProxy</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">Manager</span> {

    <span style="color:#859900">private</span> <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span>;

    <span style="color:#859900">public</span> <span style="color:#268bd2">ManagerProxy</span>(<span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span>) {
        <span style="color:#859900">this</span>.<span style="color:#268bd2">manager</span> = <span style="color:#268bd2">manager</span>;
    }

    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">handle</span>(<span style="color:#268bd2">String</span> <span style="color:#268bd2">param</span>) {
        <span style="color:#268bd2">preHandle</span>();
        <span style="color:#859900">this</span>.<span style="color:#268bd2">manager</span>.<span style="color:#268bd2">handle</span>(<span style="color:#268bd2">param</span>);
        <span style="color:#268bd2">postHandle</span>();
    }

    <span style="color:#859900">private</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">preHandle</span>() {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;Position: &#34;</span> + <span style="color:#268bd2">manager</span>.<span style="color:#268bd2">getClass</span>().<span style="color:#268bd2">getSimpleName</span>());
    }

    <span style="color:#859900">private</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">postHandle</span>() {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">SimpleDateFormat</span>(<span style="color:#2aa198">&#34;YYYY/MM/dd&#34;</span>).<span style="color:#268bd2">format</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">Date</span>()));
    }
    <span style="color:#93a1a1;font-style:italic">// ----console output:-----
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// Position: DepartmentManager
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// Today Plan: Monthly Review
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// 2017/05/24
</span><span style="color:#93a1a1;font-style:italic"></span>}
</code></pre></div><p>静态代理有其不足的地方，如果有 N 个真实对象，就需要指定 N 个代理类来代理；如果主题接口增加了方法，那么所有实现类和代理类都需要实现这个新方法。这无疑增加了代码维护的难度。另外，如果事先并不知道被代理的真实对象是什么，该如何实现代理。动态代理可以代理多个真实对象，并且可以动态指定，虽然在程序性能上不如静态代理，但在灵活性上显著优于静态代理。</p>
<h3 id="动态代理">动态代理</h3>
<p>创建动态代理的方式有多种，可以通过 JDK 内置的 <code>java.lang.reflect</code> 包、<a href="https://github.com/cglib/cglib">CGLIB</a> 实现。JDK 实现动态处理相对简单，核心是利用反射，先介绍 JDK 的动态代理实现。</p>
<h4 id="jdk-动态代理">JDK 动态代理</h4>
<p>JDK 实现动态代理的过程如下：</p>
<ol>
<li>在运行期通过反射创建实现主题接口的代理类；</li>
<li>代理类的字节码将在运行时生成并载入当前代理的 ClassLoader，运行时生成的 class，需要提供真实对象的一组接口，然后该 class 就标示已实现这一组接口，但此时创建的代理类还只是空壳，没有代理的实际作用，因为只是对外声称实现了接口，实际并没有；</li>
<li>接口所声明的方法都会委托给调用处理器 <code>InvocationHandler</code> 作统一处理，每个方法的调用都会经过 <code>InvocationHandler.invoke()</code> 方法，实现了对真实对象方法的调用，而无需对每一个方法都做一个实现；</li>
</ol>
<p>这个过程主要涉及下面两个类：</p>
<ul>
<li><code>java.lang.reflect.Proxy</code>：提供 <code>Proxy.newProxyInstance()</code> 生成代理类；</li>
<li><code>java.lang.reflect.InvocationHandler</code>：调用处理器，是一个接口，执行真实对象的方法时，会出发调用处理器的方法，动态生成的代理类需要完成的具体任务由调用处理器的实现来处理；</li>
</ul>
<p><code>Proxy.newProxyInstance()</code> 第一个参数是加载该代理类到 JVM 的类加载器；第二个参数是代理类需要实现的接口；第三个参数是调用处理器的实现。方法源码精简如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">static</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">newProxyInstance</span>(<span style="color:#268bd2">ClassLoader</span> <span style="color:#268bd2">loader</span>,
                                      <span style="color:#268bd2">Class</span>&lt;?&gt;[] <span style="color:#268bd2">interfaces</span>,
                                      <span style="color:#268bd2">InvocationHandler</span> <span style="color:#268bd2">h</span>) {
    
    <span style="color:#93a1a1;font-style:italic">// 由类加载器和接口创建指定的代理类
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#268bd2">Class</span>&lt;?&gt; <span style="color:#268bd2">cl</span> = <span style="color:#268bd2">getProxyClass0</span>(<span style="color:#268bd2">loader</span>, <span style="color:#268bd2">interfacess</span>);
    <span style="color:#93a1a1;font-style:italic">// 获得代理类的带参构造函数
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">final</span> <span style="color:#268bd2">Constructor</span>&lt;?&gt; <span style="color:#268bd2">cons</span> = <span style="color:#268bd2">cl</span>.<span style="color:#268bd2">getConstructor</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">Class</span>[] {<span style="color:#268bd2">InvocationHandler</span>.<span style="color:#268bd2">class</span>});
    <span style="color:#93a1a1;font-style:italic">// 创建代理对象实例，参数为调用处理器
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">return</span> <span style="color:#268bd2">cons</span>.<span style="color:#268bd2">newInstance</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">Object</span>[]{<span style="color:#268bd2">h</span>});
}
</code></pre></div><p><code>InvocationHandler</code> 中只有一个 <code>invoke()</code> 方法，第一个参数是代理类实例；第二个参数是被调用的方法；第三个参数是被调用方法的入参──</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">invoke</span>(<span style="color:#268bd2">Object</span> <span style="color:#268bd2">proxy</span>, <span style="color:#268bd2">Method</span> <span style="color:#268bd2">method</span>, <span style="color:#268bd2">Object</span>[] <span style="color:#268bd2">args</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">Throwable</span>;
</code></pre></div><p>实现一个动态代理的简单例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// 动态代理类
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">JdkDynamicProxyy</span> {

    <span style="color:#859900">private</span> <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span>;

    <span style="color:#859900">public</span> <span style="color:#268bd2">JdkDynamicProxyy</span>(<span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span>) {
        <span style="color:#859900">this</span>.<span style="color:#268bd2">manager</span> = <span style="color:#268bd2">manager</span>;
    }

    <span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">getProxyInstant</span>() {
        <span style="color:#859900">return</span> <span style="color:#268bd2">Proxy</span>.<span style="color:#268bd2">newProxyInstance</span>(
                <span style="color:#268bd2">manager</span>.<span style="color:#268bd2">getClass</span>().<span style="color:#268bd2">getClassLoader</span>(),
                <span style="color:#268bd2">manager</span>.<span style="color:#268bd2">getClass</span>().<span style="color:#268bd2">getInterfaces</span>(),
                <span style="color:#859900">new</span> <span style="color:#268bd2">InvocationHandler</span>() {
                    <span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">invoke</span>(<span style="color:#268bd2">Object</span> <span style="color:#268bd2">proxy</span>, <span style="color:#268bd2">Method</span> <span style="color:#268bd2">method</span>, <span style="color:#268bd2">Object</span>[] <span style="color:#268bd2">args</span>)
                            <span style="color:#859900">throws</span> <span style="color:#268bd2">Throwable</span> {
                        <span style="color:#268bd2">preHandle</span>();
                        <span style="color:#268bd2">Object</span> <span style="color:#268bd2">result</span> = <span style="color:#268bd2">method</span>.<span style="color:#268bd2">invoke</span>(<span style="color:#268bd2">manager</span>, <span style="color:#268bd2">args</span>);
                        <span style="color:#268bd2">postHandle</span>();
                        <span style="color:#859900">return</span> <span style="color:#268bd2">result</span>;
                    }
                }
        );
    }

    <span style="color:#859900">private</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">preHandle</span>() {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;Position: &#34;</span> + <span style="color:#268bd2">manager</span>.<span style="color:#268bd2">getClass</span>().<span style="color:#268bd2">getSimpleName</span>());
    }

    <span style="color:#859900">private</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">postHandle</span>() {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">SimpleDateFormat</span>(<span style="color:#2aa198">&#34;YYYY/MM/dd&#34;</span>).<span style="color:#268bd2">format</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">Date</span>()));
    }

}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// 动态代理测试
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">JdkDynamicProxyTest</span> {
    <span style="color:#268bd2">@Test</span>
    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">getProxyInstant</span>() <span style="color:#859900">throws</span> <span style="color:#268bd2">Exception</span> {
        <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">DepartmentManager</span>();
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#268bd2">manager</span>.<span style="color:#268bd2">getClass</span>());

        <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">proxy</span> = (<span style="color:#268bd2">Manager</span>) <span style="color:#859900">new</span> <span style="color:#268bd2">JdkDynamicProxyy</span>(<span style="color:#268bd2">manager</span>).<span style="color:#268bd2">getProxyInstant</span>();
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#268bd2">proxy</span>.<span style="color:#268bd2">getClass</span>());

        <span style="color:#268bd2">proxy</span>.<span style="color:#268bd2">handle</span>(<span style="color:#2aa198">&#34;Monthly Review&#34;</span>);
    }
    <span style="color:#93a1a1;font-style:italic">// ----console output----
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// class com.isudox.proxy.DepartmentManager
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// class com.sun.proxy.$Proxy4
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// Position: DepartmentManager
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// Today Plan: Monthly Review
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// 2017/05/24
</span><span style="color:#93a1a1;font-style:italic"></span>}
</code></pre></div><p>从运行结果可以看出，创建的动态代理类工作正常。</p>
<h4 id="cglib-动态代理">CGLIB 动态代理</h4>
<p>CGLIB 又被称作子类代理，它的动态代理实现方式是通过转换字节码生成新的子类，从而扩展真实对象的功能。当需要被代理的真实对象是单纯的类时，就可以使用 CGLIB 子类代理来实现动态代理，当然对接口实现类也同样支持。</p>
<p>CGLIB 包下有 <code>MethodInterceptor</code> 接口，起到拦截方法调用的作用。CGLIB 动态代理类需要实现该接口，重写 <code>intercept()</code> 方法，把被调用的方法和入参传入给真实对象。</p>
<p>还用到 CGLIB 包下的 <code>Enhancer</code> 类，通过 <code>setSuperclass()</code> 设置父类，通过 <code>setCallback()</code> 设置回调方法，类似 <code>Proxy</code> 的 <code>invoke()</code> 方法。</p>
<p>参考下面的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// CGLIB 动态代理类
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">CglibDynamicProxy</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">MethodInterceptor</span> {

    <span style="color:#859900">private</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">target</span>;

    <span style="color:#859900">public</span> <span style="color:#268bd2">CglibDynamicProxy</span>(<span style="color:#268bd2">Object</span> <span style="color:#268bd2">target</span>) {
        <span style="color:#859900">this</span>.<span style="color:#268bd2">target</span> = <span style="color:#268bd2">target</span>;
    }

    <span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">getProxyInstant</span>() {
        <span style="color:#268bd2">Enhancer</span> <span style="color:#268bd2">enhancer</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">Enhancer</span>();
        <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setSuperclass</span>(<span style="color:#859900">this</span>.<span style="color:#268bd2">target</span>.<span style="color:#268bd2">getClass</span>());
        <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setCallback</span>(<span style="color:#859900">this</span>);
        <span style="color:#859900">return</span> <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">create</span>();
    }

    <span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">intercept</span>(<span style="color:#268bd2">Object</span> <span style="color:#268bd2">o</span>, <span style="color:#268bd2">Method</span> <span style="color:#268bd2">method</span>,
                            <span style="color:#268bd2">Object</span>[] <span style="color:#268bd2">objects</span>,
                            <span style="color:#268bd2">MethodProxy</span> <span style="color:#268bd2">methodProxy</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">Throwable</span> {

        <span style="color:#268bd2">preHandle</span>();
        <span style="color:#268bd2">Object</span> <span style="color:#268bd2">result</span> = <span style="color:#268bd2">methodProxy</span>.<span style="color:#268bd2">invokeSuper</span>(<span style="color:#268bd2">o</span>, <span style="color:#268bd2">objects</span>);  <span style="color:#93a1a1;font-style:italic">// 调用父类即被代理类的方法
</span><span style="color:#93a1a1;font-style:italic"></span>        <span style="color:#268bd2">postHandle</span>();
        <span style="color:#859900">return</span> <span style="color:#268bd2">result</span>;
    }

    <span style="color:#859900">private</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">preHandle</span>() {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#2aa198">&#34;Position: &#34;</span> + <span style="color:#268bd2">target</span>.<span style="color:#268bd2">getClass</span>().<span style="color:#268bd2">getSimpleName</span>());
    }

    <span style="color:#859900">private</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">postHandle</span>() {
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">SimpleDateFormat</span>(<span style="color:#2aa198">&#34;YYYY/MM/dd&#34;</span>).<span style="color:#268bd2">format</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">Date</span>()));
    }
    
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#93a1a1;font-style:italic">// 测试
</span><span style="color:#93a1a1;font-style:italic"></span><span style="color:#859900">public</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">CglibDynamicProxyTest</span> {
    <span style="color:#268bd2">@Test</span>
    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">void</span> <span style="color:#268bd2">intercept</span>() <span style="color:#859900">throws</span> <span style="color:#268bd2">Exception</span> {
        <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">manager</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">DepartmentManager</span>();
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#268bd2">manager</span>.<span style="color:#268bd2">getClass</span>());

        <span style="color:#268bd2">Manager</span> <span style="color:#268bd2">proxy</span> = (<span style="color:#268bd2">Manager</span>) <span style="color:#859900">new</span> <span style="color:#268bd2">CglibDynamicProxy</span>(<span style="color:#268bd2">manager</span>).<span style="color:#268bd2">getProxyInstant</span>();
        <span style="color:#268bd2">System</span>.<span style="color:#268bd2">out</span>.<span style="color:#268bd2">println</span>(<span style="color:#268bd2">proxy</span>.<span style="color:#268bd2">getClass</span>());

        <span style="color:#268bd2">proxy</span>.<span style="color:#268bd2">handle</span>(<span style="color:#2aa198">&#34;Monthly Review&#34;</span>);
    }
    <span style="color:#93a1a1;font-style:italic">// ----console output----
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// class com.isudox.proxy.DepartmentManager
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// class com.isudox.proxy.DepartmentManager$$EnhancerByCGLIB$$56f0605c
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// Position: DepartmentManager
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// Today Plan: Monthly Review
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#93a1a1;font-style:italic">// 2017/05/24
</span><span style="color:#93a1a1;font-style:italic"></span>}
</code></pre></div><p>从运行结果可以看出，代码里的 <code>proxy</code> 实例是被代理的真实对象的子类，这是和 JDK 动态代理明显不同的地方，因此 CGLIB 可以实现对非接口实现类的动态代理。</p>
<h3 id="小结">小结</h3>
<p>对代理模式做个简单的小结──</p>
<ol>
<li>Subject 定义 ReaelSubject 和 Proxy 的公共接口，目的是让 Proxy 可以代替 RealSubject；</li>
<li>RealSubject 定义被代理的目标实体；</li>
<li>Proxy 会需持有目标对象的引用，使得代理可以访问到目标实体；</li>
<li>Proxy 对外提供和目标对象接口一致的实现，即直接通过代理替代目标实体；</li>
</ol>
<h2 id="spring-aop-实现">Spring AOP 实现</h2>
<p>在了解了动态代理的实现过程后，就可以深入源码对 Spring AOP 的实现原理一探究竟了。引用官方文档里的一段话──</p>
<blockquote>
<p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any <strong>interface (or set of interfaces)</strong> to be proxied.
Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. CGLIB is used by default if a business object <strong>does not implement an interface</strong>.</p>
</blockquote>
<p>简单地说，Spring AOP 对接口实现的类，默认采用 JDK 动态代理；对没有实现接口的类，则默认采用 CGLIB 实现动态代理。Spring 会自行判断，无需开发者人为去选择。</p>
<h3 id="jdkdynamicaopproxy">JdkDynamicAopProxy</h3>
<p>还是参考本文开头的 Spring AOP 示例代码，在执行 <code>run()</code> 方法处加断点 debug，可以看到 <code>PrinterService</code> 实例是代理对象实例：</p>
<p><img src="https://o70e8d1kb.qnssl.com/spring-aop-breakpoint.jpeg" alt=""></p>
<p>因为目标对象实现了接口，Spring AOP 使用了内部封装的 <code>JdkDynamicAopProxy</code> 类实现动态代理，底层还是 JDK 动态代理。来看下它的源码──</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">final</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">JdkDynamicAopProxy</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">AopProxy</span>, <span style="color:#268bd2">InvocationHandler</span>, <span style="color:#268bd2">Serializable</span> {
    ...
}
</code></pre></div><p><code>Serializable</code> 无需赘述了，先来看 <code>AopProxy</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">interface</span> <span style="color:#cb4b16">AopProxy</span> {
    <span style="color:#93a1a1;font-style:italic">// 通过 AopProxy 默认的类加载器获取新的代理对象
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#268bd2">Object</span> <span style="color:#268bd2">getProxy</span>();
    <span style="color:#93a1a1;font-style:italic">// 通过指定的类加载获取新的代理对象
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#268bd2">Object</span> <span style="color:#268bd2">getProxy</span>(<span style="color:#268bd2">ClassLoader</span> <span style="color:#268bd2">classLoader</span>);
}
</code></pre></div><p>再来看 <code>JdkDynamicAopProxy</code> 对 <code>AopProxy</code> 的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#268bd2">@Override</span>
<span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">getProxy</span>() {
    <span style="color:#859900">return</span> <span style="color:#268bd2">getProxy</span>(<span style="color:#268bd2">ClassUtils</span>.<span style="color:#268bd2">getDefaultClassLoader</span>());
}

<span style="color:#268bd2">@Override</span>
<span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">getProxy</span>(<span style="color:#268bd2">ClassLoader</span> <span style="color:#268bd2">classLoader</span>) {
    <span style="color:#859900">if</span> (<span style="color:#268bd2">logger</span>.<span style="color:#268bd2">isDebugEnabled</span>()) {
        <span style="color:#268bd2">logger</span>.<span style="color:#268bd2">debug</span>(<span style="color:#2aa198">&#34;Creating JDK dynamic proxy: target source is &#34;</span> + <span style="color:#859900">this</span>.<span style="color:#268bd2">advised</span>.<span style="color:#268bd2">getTargetSource</span>());
    }
    <span style="color:#268bd2">Class</span>&lt;?&gt;[] <span style="color:#268bd2">proxiedInterfaces</span> = <span style="color:#268bd2">AopProxyUtils</span>.<span style="color:#268bd2">completeProxiedInterfaces</span>(<span style="color:#859900">this</span>.<span style="color:#268bd2">advised</span>, <span style="color:#859900;font-weight:bold">true</span>);
    <span style="color:#268bd2">findDefinedEqualsAndHashCodeMethods</span>(<span style="color:#268bd2">proxiedInterfaces</span>);
    <span style="color:#93a1a1;font-style:italic">// 调用 JDK Proxy 生成代理对象实例
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#859900">return</span> <span style="color:#268bd2">Proxy</span>.<span style="color:#268bd2">newProxyInstance</span>(<span style="color:#268bd2">classLoader</span>, <span style="color:#268bd2">proxiedInterfaces</span>, <span style="color:#859900">this</span>);
}
</code></pre></div><p>参考前文讲的 JDK 动态代理，<code>Proxy.newProxyInstance()</code> 方法传入类加载器，被代理的接口，以及 InvocationHandler 实现，生成动态代理对象的实例。</p>
<p><code>JdkDynamicAopProxy</code> 中对 <code>InvocationHandler.invoke()</code> 的实现本质上和前面的实例代码也是一样的。</p>
<h3 id="cglibaopproxy">CglibAopProxy</h3>
<p>从源码中还能看到，在 Spring AOP 中，<code>AopProxy</code> 还有一个实现，就是 <code>CglibAopProxy</code>，这个类封装了 CGLIB 创建动态代理的实现。其定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">class</span> <span style="color:#cb4b16">CglibAopProxy</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">AopProxy</span>, <span style="color:#268bd2">Serializable</span> {
    ...
}
</code></pre></div><p>奇怪的是，这似乎和之前自己实现的 <code>CglibDynamicProxy</code> 不一样，它没有实现 CGLIB 的 <code>MethodInterceptor</code>。这里有一点需要注意，代理类实例实际上是由 <code>Enhancer.create()</code> 生成的，而在构建 <code>Enhancer</code> 实例时，需要通过 <code>Enhancer.setCallback()</code> 设置回调方法，这个回调方法是 <code>MethodInterceptor</code> 的具体实现。所以只需要将回调方法实现 <code>MethodInterceptor</code> 即可。具体看源码是怎么做的：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#268bd2">@Override</span>
<span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">getProxy</span>(<span style="color:#268bd2">ClassLoader</span> <span style="color:#268bd2">classLoader</span>) {
    <span style="color:#93a1a1;font-style:italic">// 配置 CGLIB Enhancer
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#268bd2">Enhancer</span> <span style="color:#268bd2">enhancer</span> = <span style="color:#268bd2">createEnhancer</span>();
    <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setSuperclass</span>(<span style="color:#268bd2">proxySuperClass</span>);
    <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setInterfaces</span>(<span style="color:#268bd2">AopProxyUtils</span>.<span style="color:#268bd2">completeProxiedInterfaces</span>(<span style="color:#859900">this</span>.<span style="color:#268bd2">advised</span>));
    <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setNamingPolicy</span>(<span style="color:#268bd2">SpringNamingPolicy</span>.<span style="color:#268bd2">INSTANCE</span>);
    <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setStrategy</span>(<span style="color:#859900">new</span> <span style="color:#268bd2">ClassLoaderAwareUndeclaredThrowableStrategy</span>(<span style="color:#268bd2">classLoader</span>));

    <span style="color:#93a1a1;font-style:italic">// 获取回调方法，即 MethodInterceptor 的实现
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#268bd2">Callback</span>[] <span style="color:#268bd2">callbacks</span> = <span style="color:#268bd2">getCallbacks</span>(<span style="color:#268bd2">rootClass</span>);
    ...
    <span style="color:#93a1a1;font-style:italic">// 生成代理类并创建代理实例
</span><span style="color:#93a1a1;font-style:italic"></span>	<span style="color:#859900">return</span> <span style="color:#268bd2">createProxyClassAndInstance</span>(<span style="color:#268bd2">enhancer</span>, <span style="color:#268bd2">callbacks</span>);
}

<span style="color:#859900">protected</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">createProxyClassAndInstance</span>(<span style="color:#268bd2">Enhancer</span> <span style="color:#268bd2">enhancer</span>, <span style="color:#268bd2">Callback</span>[] <span style="color:#268bd2">callbacks</span>) {
    <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setInterceptDuringConstruction</span>(<span style="color:#859900;font-weight:bold">false</span>);
    <span style="color:#93a1a1;font-style:italic">// 在这设置了回调方法 callbacks
</span><span style="color:#93a1a1;font-style:italic"></span>    <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">setCallbacks</span>(<span style="color:#268bd2">callbacks</span>);
    <span style="color:#859900">return</span> (<span style="color:#859900">this</span>.<span style="color:#268bd2">constructorArgs</span> != <span style="color:#859900;font-weight:bold">null</span> ?
            <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">create</span>(<span style="color:#859900">this</span>.<span style="color:#268bd2">constructorArgTypes</span>, <span style="color:#859900">this</span>.<span style="color:#268bd2">constructorArgs</span>) :
            <span style="color:#268bd2">enhancer</span>.<span style="color:#268bd2">create</span>());
}
</code></pre></div><p>从源码中可以发现，<code>CglibDynamicProxy</code> 是通过调用 <code>getCallbacks()</code> 来获取回调方法的，再看它的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">private</span> <span style="color:#268bd2">Callback</span>[] <span style="color:#268bd2">getCallbacks</span>(<span style="color:#268bd2">Class</span>&lt;?&gt; <span style="color:#268bd2">rootClass</span>) <span style="color:#859900">throws</span> <span style="color:#268bd2">Exception</span> {
    ...
    <span style="color:#93a1a1;font-style:italic">// Choose an &#34;aop&#34; interceptor (used for AOP calls).
</span><span style="color:#93a1a1;font-style:italic"></span>	<span style="color:#268bd2">Callback</span> <span style="color:#268bd2">aopInterceptor</span> = <span style="color:#859900">new</span> <span style="color:#268bd2">DynamicAdvisedInterceptor</span>(<span style="color:#859900">this</span>.<span style="color:#268bd2">advised</span>);
    ...
}

<span style="color:#859900">private</span> <span style="color:#859900">static</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">DynamicAdvisedInterceptor</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">MethodInterceptor</span>, <span style="color:#268bd2">Serializable</span> {
    <span style="color:#268bd2">@Override</span>
    <span style="color:#859900">public</span> <span style="color:#268bd2">Object</span> <span style="color:#268bd2">intercept</span>(<span style="color:#268bd2">Object</span> <span style="color:#268bd2">proxy</span>, <span style="color:#268bd2">Method</span> <span style="color:#268bd2">method</span>, <span style="color:#268bd2">Object</span>[] <span style="color:#268bd2">args</span>, <span style="color:#268bd2">MethodProxy</span> <span style="color:#268bd2">methodProxy</span>)
            <span style="color:#859900">throws</span> <span style="color:#268bd2">Throwable</span> {
        ...
    }
}
</code></pre></div><p><code>DynamicAdvisedInterceptor</code> 确实是实现了 <code>MethodInterceptor</code>。</p>
<h2 id="qa">Q&amp;A</h2>
<p>Q: 为什么 JDK 只能动态代理接口实现类，而不能对类创建动态代理？
A: 因为 Java 是单继承的，每个代理类都继承了 Proxy 类，因此不能对类创建代理类，只能对接口实现类。</p>
<p>Q: JDK 如何确保对代理对象方法的调用都会经过调用处理器 <code>InvocationHandler.invoke()</code> 方法？
A: JDK 在创建动态代理类时，内部的过程可以简单理解为下面的过程，所以只要是对代理类方法的调用，都会经过 <code>invoke()</code> 处理。</p>
<div class="highlight"><pre tabindex="0" style="color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#859900">public</span> <span style="color:#859900">final</span> <span style="color:#859900">class</span> <span style="color:#cb4b16">$Proxy1</span> <span style="color:#859900">extends</span> <span style="color:#268bd2">Proxy</span> <span style="color:#859900">implements</span> <span style="color:#268bd2">Subject</span>{
    <span style="color:#859900">private</span> <span style="color:#268bd2">InvocationHandler</span> <span style="color:#268bd2">h</span>;
    <span style="color:#859900">private</span> <span style="color:#268bd2">$Proxy1</span>() {}
    <span style="color:#859900">public</span> <span style="color:#268bd2">$Proxy1</span>(<span style="color:#268bd2">InvocationHandler</span> <span style="color:#268bd2">h</span>) {
        <span style="color:#859900">this</span>.<span style="color:#268bd2">h</span> = <span style="color:#268bd2">h</span>;
    }
    <span style="color:#859900">public</span> <span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">request</span>(<span style="color:#859900;font-weight:bold">int</span> <span style="color:#268bd2">i</span>) {
        <span style="color:#268bd2">Method</span> <span style="color:#268bd2">method</span> = <span style="color:#268bd2">Subject</span>.<span style="color:#268bd2">class</span>.<span style="color:#268bd2">getMethod</span>(<span style="color:#2aa198">&#34;request&#34;</span>, <span style="color:#859900">new</span> <span style="color:#268bd2">Class</span>[] {<span style="color:#859900;font-weight:bold">int</span>.<span style="color:#268bd2">class</span>});
        <span style="color:#859900">return</span> (<span style="color:#268bd2">Integer</span>) <span style="color:#268bd2">h</span>.<span style="color:#268bd2">invoke</span>(<span style="color:#859900">this</span>, <span style="color:#268bd2">method</span>, <span style="color:#859900">new</span> <span style="color:#268bd2">Object</span>[] {<span style="color:#859900">new</span> <span style="color:#268bd2">Integer</span>(<span style="color:#268bd2">i</span>)});
    }
}
</code></pre></div><p>Q: 代理模式和装饰器模式的区别？
A: 这两种设计模式非常相似，都是用一个类包装目标类，但在使用目的上有些许不同。代理模式侧重增强对目标对象的控制，装饰器模式侧重对目标对象的增强。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://book.douban.com/subject/26767354/">Spring 实战</a></li>
<li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html">Spring Docs</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/">Spring AOP 实现原理与 CGLIB 应用</a></li>
</ul>
</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://isudox.com/tags/Java">Java</a></li>
      <li><a href="https://isudox.com/tags/Spring">Spring</a></li>
    </ul>
  </footer>

  

<div id="disqus_thread"></div>
<script>
    

    

    (function () {
        
        
        if (window.location.hostname == "localhost")
            return;
        var d = document, s = d.createElement('script');
        
        var disqus_shortname = 'isudox';
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article></main>
<footer class="footer">
  <span>&copy; 2015 - 2022</span>
  <span>&middot;</span>
  <span><a href="https://isudox.com/">I sudo X</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/isudox/hugo-theme-nova/" rel="noopener" target="_blank">Nova</a></span>
</footer>
</body>

</html>

