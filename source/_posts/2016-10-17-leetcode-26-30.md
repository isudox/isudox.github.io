---
title: LeetCode 26-30
tags:
  - Algorithm
  - LeetCode
categories:
  - Coding
date: 2016-10-17 17:09:15
---


三个月没上 LeetCode了，最近工作不顺心，好想被虐个痛快，接着写 LeetCode 第 26 至 30 题。
<!-- more -->

### Remove Duplicates from Sorted Array

第 26 题 [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

> 给定一个有序数组，去掉其中重复的元素，并返回新数组的长度。
> 不要为其他数组分配额外的空间，必须在给定的内存中完成。

假设传入的数组是 `[1, 1, 2]`，得到的结果应该是 2。题意很简单，但是有两个注意点，一个是该数组是有序的，即从小到大排列，另一个是不允许分配新数组的存储空间，这就意味着不用创建新的数组来保存数据，也不能通过 Set 来过滤重复元素。

因为第二点的限，只能在给定的数组上进行数值比较的同时，计算非重复元素的数量；因为第一点的设定，所以可以做到对数组只遍历一次。具体做法就是，在遍历数组元素时，比较前后两个元素，如果相等，则重复元素的数量加一，同时移动当前遍历位置，直到遍历到数组最末元素。

编写 Java 解法如下：

```java
// Rejected
public class Solution {
    public int removeDuplicates(int[] nums) {
        int count = nums.length;
        int dup = 0;
        if (count < 2)
            return count;
        for (int i = 0; i < count - 1; i++) {
            if (nums[i] == nums[i + 1])
                dup++;
        }
        return count - dup;
    }
}
```

本地测试结果是正确的，但是提交的 LeetCode 上却被否决，因为上面的方法只计算出了非重复元素的个数 n，没有考虑把有序数组前 n 位修改成正确的有序非重复元素。因此在遍历的同时，需要修改发现重复的位置上的元素。

```java
// Accepted √
public class Solution {
    public int removeDuplicates(int[] nums) {
        int count = nums.length;
        if (count < 2)
            return count;
        int left = 0, right = 1;
        while (right < count) {
            if (nums[left] == nums[right]) {
                right++;
            } else {
                nums[++left] = nums[right++];
            }
        }
        return left + 1;
    }
}
```

**********************************************

### Remove Element

第 27 题 [Remove Element](https://leetcode.com/problems/remove-element/)

> 给定一个数组和一个数，移除数组中所有和给定数相同的数，并返回该数组修改后的长度。
> 不要为其他数组分配额外的空间，必须在给定的内存中完成。
> 数组元素的顺序可以被改变。

例如传入的数组为 `[3, 2, 2, 3]`，数值是 3，函数处理后返回的长度是 2，且数组的前两个元素是 2。

这道题比上题简单，无非就是数组元素和给定数值的比较，如果相等，则去掉，如果不等则保留。唯一需要想办法的是如何把要保留的元素放在数组前面的位置。当找到第一个和给定数不等的元素时，就把它放在数组的首位，再找下一个不等的元素，放在数组的第二个位置，这样递推直到遍历完成。

```java
public class Solution {
    public int removeElement(int[] nums, int val) {
        int index = 0;
        for (int num : nums) {
            if (num != val)
                nums[index++] = num;
        }
        return index;
    }
}
```

**********************************************
