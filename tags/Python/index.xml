<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on I sudo X</title>
    <link>https://isudox.com/tags/python/</link>
    <description>Recent content in Python on I sudo X</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Apr 2018 23:20:03 +0000</lastBuildDate>
    
	<atom:link href="https://isudox.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JavaScript ES6 和 Python 中的 Generator</title>
      <link>https://isudox.com/2018/04/22/generators-in-python-es6/</link>
      <pubDate>Sun, 22 Apr 2018 23:20:03 +0000</pubDate>
      
      <guid>https://isudox.com/2018/04/22/generators-in-python-es6/</guid>
      <description>这几天折腾的一个 RSS 聚合爬虫，前端部分涉及到 redux-saga，对 ES6 里引入的 Generator 运用很花哨，看起来会云里雾里，其实和 Python 的 generator、yield 从思想上到写法上基本是一致的，之前也写过 Python 里的用法，这里也简单的写下我对动态语言里 generator 的学习和理解。
通识 首先，generator 本质上还是 function，只是行为略微特殊。 普通 function 会在执行结束时通过 return 返回； generator 可以中断 function 的执行过程，并重新回到断点现场继续执行。具体实现就是通过 yield 将结果返回给调用方并中断，通过 next() 方法继续回到断点再执行到下一个 yield 断点处。 普通函数只会返回一次，就是在执行结束的时候；generator 函数在执行过程中可以多次返回，即在 yield 断点处取代了 return。
还有一个和 generator 紧密相关的概念是 iterator，简单的描述二者的关系就是──generator 实现的目的是生成一个 iterator，它是 iterable 的，也就是说是可以循环遍历的。
ES6 JavaScript ES6 的 generator 和普通函数相比，最明显的不同在于它的关键字包含星号 * 和 yield，比如 MDN 文档上的代码示例：
function* generator(i) { yield i; yield i + 10; } var gen = generator(10); console.</description>
    </item>
    
    <item>
      <title>读 Flask 源码：源码结构</title>
      <link>https://isudox.com/2017/02/14/explore-flask-source-code-structure/</link>
      <pubDate>Tue, 14 Feb 2017 19:47:11 +0000</pubDate>
      
      <guid>https://isudox.com/2017/02/14/explore-flask-source-code-structure/</guid>
      <description>打算对 Flask 的学习做个整理，以 Flask 的 GitHub 代码库的 master 分支为参考。其实早期的 0.3 版还是单文件，整个 flask.py 加上注释也只有 1426 行代码，非常简洁，很适合作为 Python 源码学习的教材。
拿到源码先不着急，就像读书一样，不妨浏览下目录，以便有个全局的了解。Flask 的源码有一个非常好的优点，就是它的注释非常完备，即使不看源码，只看注释，也能有个大概的理解。
从 Flask 根目录下的 setup.py 可以看到，Flask 依赖的组件主要有 3 个：
 Werkzeug：一个 HTTP 和 WSGI 的工具集； Jinja2：Python 的前端模板引擎； itsdangerous：处理并传递可信数据的辅助函数集；  Flask 的核心代码都在 flask 目录下，其目录结构如下：
flask ├── ext │ └── __init__.py flask 扩展 ├── __init__.py 导入模块 ├── __main__.py 命令行运行 ├── _compat.py Py2/3 兼容性模块 ├── app.py 核心模块 ├── blueprints.py 蓝图模块 ├── cli.py 命令行支持模块 ├── config.py flask 配置模块 ├── ctx.</description>
    </item>
    
    <item>
      <title>理解 Python 生成器</title>
      <link>https://isudox.com/2016/10/26/python-generator-guide/</link>
      <pubDate>Wed, 26 Oct 2016 20:23:03 +0000</pubDate>
      
      <guid>https://isudox.com/2016/10/26/python-generator-guide/</guid>
      <description>在 Python 里创建一个有一定规律的序列，很直观的做法就是在循环里创建序列的各个元素。但 Python 有更加符合 Pythonic 风格的做法，就是用生成器来实现。
举个被写滥的例子吧，用 Python 生成 Fibonacci 数列的前 n 个数字，该怎么做？
def fib(n): if n &amp;lt; 2: return 1 return fib(n - 1) + fib(n - 2) def gen_fib(n): res = [] for i in range(n): res.append(fib(i)) return res 而 Pythonic 的写法是像下面这样：
def fib(n): if n &amp;lt; 2: return 1 return fib(n - 1) + fib(n - 2) def gen_fib(n): for i in range(n): yield fib(i) 查看把上面两种做法的返回结果，可以找到二者的不同：</description>
    </item>
    
    <item>
      <title>读 Flask 源码：Context</title>
      <link>https://isudox.com/2016/10/02/flask-context-guide/</link>
      <pubDate>Sun, 02 Oct 2016 20:11:40 +0000</pubDate>
      
      <guid>https://isudox.com/2016/10/02/flask-context-guide/</guid>
      <description>Flask Context 类似 Spring 框架的核心组件 Context，给应用程序提供运行时所需的环境（包含状态、变量等）的快照。如果程序本身就包含了运行所需的完备条件，那么它可以独立运行了；如果程序需要外部环境的支持，Context 的存在就有意义。比如 Flask Web 开发中常用的 current_app、request 都是 Context，可以在不同方法中调用，并且实现通信及交互。
Context 的实现 Flask 提供了 4 个 Context：
   Context 类型 说明     flask.current_app Application Context 当前 app 的实例对象   flask.g Application Context 处理请求时用作临时存储的对象   flask.request Request Context 封装了 HTTP 请求中的内容   flask.session Request Context 存储了用户回话    这些 Context 分为 Application Context 和 Request Context 两类：
 Application Context: 是提供给由 app = Flask(__name__) 所创建的 Flask app 的 Context； Request Context: 是客户端发起 HTTP 请求时，Flask 对象为 HTTP 请求对象所创建的 Context；  这些 Context 定义在 Flask 源码（v0.</description>
    </item>
    
    <item>
      <title>理解 Python 装饰器</title>
      <link>https://isudox.com/2016/09/09/python-decorator-guide/</link>
      <pubDate>Fri, 09 Sep 2016 22:42:36 +0000</pubDate>
      
      <guid>https://isudox.com/2016/09/09/python-decorator-guide/</guid>
      <description>前一篇水文里记录的 Click 包，大量的运用了 Python 的装饰器。装饰器是非常实用的编程思想，Java 开发里经常看到的 AOP 也是同样的思想。Python 装饰器使用很简单，只需要在需要装饰的方法前加上注解 @decorator 函数进行包裹。但是经常用不代表能理解到位，下文就来尝试捋一捋 Python 装饰器的来龙去脉。
管窥装饰器 下面是一个很简单的 Python 方法：
def call(): print(&amp;#39;call me&amp;#39;) call() 很简单，这会得到 &amp;ldquo;call me&amp;rdquo; 的文本输出。现在增加一个时间标记，告知是什么时间呼叫的我，可以这么改：
import time def call(): print(&amp;#39;call me&amp;#39;) print(&amp;#39;at &amp;#39;, time.strftime(&amp;#39;%Y-%m-%d%H:%M:%S&amp;#39;, time.localtime(time.time())))) call() 这么做有一个麻烦的地方，就是在 call() 方法内部做了改动。在很多场景下，我们不希望去改变方法本身的行为，因为这个方法可能在很多地方都被调用了，如果在方法内部做了修改，那么对每个调用都会产生影响，但我们只希望在某些调用时才去改变它的行为。比较常见的实用场景如用户登录拦截。
不改变函数本身，那么该如何对 call() 加上时间标记呢？这就到装饰器大显身手的时候了。装饰器可以把被装饰的方法包裹起来，被装饰者本身的行为不会变，装饰器只是在它之外添加了额外的功能。下面这张图解释的很形象：
import time def call(): print(&amp;#39;call me &amp;#39;) def mark_time(func): def wrapper(*args, **kwargs): func() print(&amp;#39;at&amp;#39;, time.strftime(&amp;#39;%Y-%m-%d%H:%M:%S&amp;#39;, time.localtime(time.time()))) return wrapper call = mark_time(call) call() 上面就实现了简朴的装饰器，Python 内置了对装饰器的语法支持，可以更便捷的实现装饰功能，就是上面提到的 @decorator，这相当于是 func = decorator(func) 的作用。</description>
    </item>
    
    <item>
      <title>Python Click 学习笔记</title>
      <link>https://isudox.com/2016/09/03/learning-python-package-click/</link>
      <pubDate>Sat, 03 Sep 2016 01:22:37 +0000</pubDate>
      
      <guid>https://isudox.com/2016/09/03/learning-python-package-click/</guid>
      <description>Click 是 Flask 的团队 pallets 开发的优秀开源项目，它为命令行工具的开发封装了大量方法，使开发者只需要专注于功能实现。恰好我最近在开发的一个小工具需要在命令行环境下操作，就写个学习笔记。
国际惯例，先来一段 &amp;ldquo;Hello World&amp;rdquo; 程序（假定已经安装了 Click 包）。
# hello.py import click @click.command() @click.option(&amp;#39;--count&amp;#39;, default=1, help=&amp;#39;Number of greetings.&amp;#39;) @click.option(&amp;#39;--name&amp;#39;, prompt=&amp;#39;Your name&amp;#39;, help=&amp;#39;The person to greet.&amp;#39;) def hello(count, name): &amp;#34;&amp;#34;&amp;#34;Simple program that greets NAME for a total of COUNT times.&amp;#34;&amp;#34;&amp;#34; for x in range(count): click.echo(&amp;#39;Hello %s!&amp;#39; % name) if __name__ == &amp;#39;__main__&amp;#39;: hello() 执行 python hello.py --count=3，不难猜到控制台的输出结果。除此之外，Click 还悄悄地做了其他的工作，比如帮助选项：
$ python hello.py --help Usage: hello.py [OPTIONS] Simple program that greets NAME for a total of COUNT times.</description>
    </item>
    
    <item>
      <title>Gunicorn 驱动工厂模式 Flask 应用</title>
      <link>https://isudox.com/2016/08/29/running-flask-with-gunicorn-in-application-factory/</link>
      <pubDate>Mon, 29 Aug 2016 13:45:50 +0000</pubDate>
      
      <guid>https://isudox.com/2016/08/29/running-flask-with-gunicorn-in-application-factory/</guid>
      <description>之前用 uWsgi 部署过 Django 应用，但当时的开发和部署都还手生，有很多不合理的地方，最近写的一个 Flask 应用，用了另一个 wsgi 容器 —— Gunicorn，并且利用工厂模式对不同开发环境进行了隔离。工厂模式下的 Flask 应用在用 Gunicorn 部署时，需要做一点针对性的改动。
基础的 Flask 应用部署 先写一个最简单的 Flask 应用 hello：
# hello.py from flask import Flask app = Flask(__name__) @app.route(&amp;#39;/&amp;#39;) def hello_world(): return &amp;#34;Hello World!&amp;#34; if __name__ == &amp;#39;__main__&amp;#39;: app.run(host=&amp;#39;0.0.0.0&amp;#39;, port=5000) 然后用 Python 去解释执行这段脚本即可，Flask 内置了简易的 HTTP Server 来处理请求。
当然这仅仅供本地测试的运行方式，线上部署的方案，通常是采用 wsgi 程序来驱动 Flask / Django 应用。Gunicorn 是性能比较好的一个方案（有时间我会做一次 Gunicorn 与 uWsgi 的性能压测对比）。Gunicorn 的驱动 hello 应用的命令如下：
gunicorn -w 4 -b 127.0.0.1:5000 hello:app Gunicorn 的常用运行参数说明：</description>
    </item>
    
    <item>
      <title>Django 部署的非最佳实践</title>
      <link>https://isudox.com/2016/06/01/non-best-practice-of-django-deployment/</link>
      <pubDate>Wed, 01 Jun 2016 17:24:27 +0000</pubDate>
      
      <guid>https://isudox.com/2016/06/01/non-best-practice-of-django-deployment/</guid>
      <description>上周末接到急差，要重新部署之前开发的 Django 项目。磕磕绊绊遇到很多预想不到的问题，也发现自己对 Django 应用的部署依旧很生疏，遂记一篇水文。
一些题外话 Django 工程结构 在 Django 官方文档里，新建 Django 工程用下面的命令完成：
django-admin startproject mysite 这样创建的工程根目录下，会生成一个和项目名称同名的子目录，存放 settings.py wsgi.py 等文件。这样做肯定没问题，但是没必要，也不优雅。对此 Kenneth Reitz 的建议是，在命令的后面加一 . 号：
django-admin.py start-project mysite . 这样，Django 工程的配置文件就存放在根目录下了。
虚拟环境 virtualenv 一般在测试服务器上，用 virtualenv 把不同版本的环境隔离开来是首选的方案。此外还有一个工具 virtualenvwrapper，来管理由 virtualenv 虚拟出来的 Python 环境，非常实用。
pip 安装 virtualenvwrapper 后，需要设置几个全局环境变量。可以把下面的配置添加进 shell 的配置文件里，比如我用的 zsh，那么就是添加进 .zshrc 文件：
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.4 export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh 分别指定默认的 Python 版本和 Python 虚拟环境的目录。设置后，就可以非常方便的通过 workon 命令切换已安装的 Python 虚拟环境，而无需定向到虚拟环境的路径。
导出 pip 列表 在有了 Python 虚拟环境后，还得有快速安装 pip 包的方法，pip 提供了导出 pip 列表的功能 freeze，以及快速安装工程所需 pip 包的功能 install：</description>
    </item>
    
    <item>
      <title>阿里大鱼短信 SDK 迁移到 Python 3.x</title>
      <link>https://isudox.com/2016/02/02/migrate-alidayu-to-py3-from-py2/</link>
      <pubDate>Tue, 02 Feb 2016 11:05:24 +0000</pubDate>
      
      <guid>https://isudox.com/2016/02/02/migrate-alidayu-to-py3-from-py2/</guid>
      <description>近期课余时间开发一个基于 Django 的 RESTful Web Service，需要接入短信验证发送功能，比较之后选定阿里大鱼的解决方案。
然而，选 Python 作为技术栈的悲催之处在于，虽然 Python 的第三方库和生态很强大，但是就国内的开发圈而言，Python 是一个相对小众的流派，又由于 Python 2.x 和 Python 3.x 的分化，许多第三方库并没有跟进 Python 3，导致很多时候用 Python 会有些捉襟见肘，尤其是像我这种野路子的 Python 开发。
比如阿里大鱼的短信方案，虽然相比其他厂商很良心的在 PHP 、 Java 版 SDK 之外，友情附赠了 Python 版，但集成进 Django 工程并 debug 后，真是握了棵草，它是基于 Python 2.x 开发的，翻了下开发包源码文件，署名为 “lihao” 的这位阿里同学是在 2012 年更新的源码，这竟是一份蒙尘多年的代码啊，当时我的内心是奔溃的……
 自己动手，丰衣足食。——《毛选》
 阿里大鱼短信开发包的源码并不复杂，来来去去无非一些 request，response 和 string 的处理，底层都是在阿里服务端 api 里实现的，短信包只是提供 api 调用、处理功能，因此迁移工作倒也不是很令人拙计。下面就把我填的坑一一道来（难免有遗忘和疏漏，见谅）——
一号坑 # 如果parameters是字典类 keys = parameters.keys() 不出所料的话，控制台会输出 &amp;gt;&amp;gt;&amp;gt;TypeError: &#39;dict_keys&#39; object does not support indexing 这是一大坑，在 Python 3.</description>
    </item>
    
  </channel>
</rss>