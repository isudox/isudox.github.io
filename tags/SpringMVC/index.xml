<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SpringMVC on I sudo X</title>
    <link>https://isudox.com/tags/springmvc/</link>
    <description>Recent content in SpringMVC on I sudo X</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Nov 2016 00:31:58 +0000</lastBuildDate>
    
	<atom:link href="https://isudox.com/tags/springmvc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>CORS 跨域调试记录</title>
      <link>https://isudox.com/posts/2016-11-12-cors-in-action/</link>
      <pubDate>Sat, 12 Nov 2016 00:31:58 +0000</pubDate>
      
      <guid>https://isudox.com/posts/2016-11-12-cors-in-action/</guid>
      <description>之前写了篇关于 JSONP 和 CORS 解决跨域请求的博客，在最近和深圳凹凸团队前后端联调时实打实的实战了一把 CORS。还是应了纸上得来终觉浅的老话，因为实际运用中会存在不同的状况，只是看文档理解概念并不能真正成为实战派。
这次联调采用前后端分离的方式，后端由 Spring MVC 提供数据接口，前端通过异步的方式做数据渲染，和以往不同的是，由于前端开发全部交给深圳的凹凸实验室，所以静态文件都跑在独立的一个域名上，就是京东的通天塔项目。因此所有来自前端的请求都成了跨域请求。
JSONP 确实是通过一种巧妙的伎俩解决了跨域请求被浏览器拒绝的问题，但是它并不能解决 POST 跨域，联调的接口是跨域上传头像，采用 POST 发送 FormData 对象的方式。所以由服务端 CORS 来处理。
对于服务端，Spring MVC 设置 CORS 很简单，如果 springframework 版本是 4.2 及以上，Spring MVC 可以直接由注解 @CrossOrigin 对标记的控制器方法设置 CORS。例如下面的示例代码：
@CrossOrigin(origins = &amp;#34;http://localhost:9000&amp;#34;) @GetMapping(&amp;#34;/greeting&amp;#34;) public Greeting greeting(@RequestParam(required=false, defaultValue=&amp;#34;World&amp;#34;) String name) { System.out.println(&amp;#34;==== in greeting ====&amp;#34;); return new Greeting(counter.incrementAndGet(), String.format(template, name)); } @CrossOrigin 注解可以通过设置 origins、methods、maxAge、allowHeaders、allowCredentials 等参数来确定 CORS 接受跨域的来源域，请求类型，请求头等。如果 origins 设置为星号，则对所有来源域的请求都允许跨域，methods 设置为 POST 就只允许请求类型为 POST 的跨域请求。
前端正常发送异步请求，类似如下代码：
var formData = new FormData(); formData.</description>
    </item>
    
  </channel>
</rss>