<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I sudo X</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isudox.com/"/>
  <updated>2019-03-29T14:17:33.182Z</updated>
  <id>https://isudox.com/</id>
  
  <author>
    <name>sudoz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-39 Combination Sum</title>
    <link href="https://isudox.com/2019/03/29/leetcode-39-combination-sum/"/>
    <id>https://isudox.com/2019/03/29/leetcode-39-combination-sum/</id>
    <published>2019-03-29T13:54:41.000Z</published>
    <updated>2019-03-29T14:17:33.182Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum</a></p><p>Medium</p></blockquote><a id="more"></a><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p><p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including <code>target</code>) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Obviously, what we have to do to solve this prolem is traversal. Then let’s think how to reduce the comlexity of traversal.</p><p>Let’s say we’ve already find out some numbers stored in a <code>list</code>, if the next number <code>x</code> in candidate numbers is less than <code>target - sum(list)</code>, then we can append this number in <code>list</code> ans continue to find next number <code>y</code>;</p><p>If <code>x</code> equals to <code>target - sum(list)</code> then we find out one combination , and if the candidate numbers is in ascending order, there is no need to check the next number <code>y</code>, we just stop here and move back to last position, put the next number after <code>x</code> and check the sum.</p><p>Thus, we need to sort these candidate numbers firstly. Let’s assume the argument <code>candidates</code> is <code>[a, b]</code>, and <code>a &lt; b</code>, imagine a tree as followed:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         0</span><br><span class="line">     /       \</span><br><span class="line">    a         b</span><br><span class="line"> /     \   /     \</span><br><span class="line">a       b a       b</span><br></pre></td></tr></table></figure><ul><li>if <code>a + a &lt; target</code>, then try to test <code>a + b</code>;</li><li>if <code>a + a = target</code>, then pop the newest appended number and return to the last node of first <code>a</code>, pop the last number and try the sibling number <code>b</code>;</li></ul><p>Here we make it clear that this is a recursive algorithm, which we should record current list which contains the numbers we get from the ordered candidates and the index of the number we start to test.</p><p>Show you the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combination_sum</span><span class="params">(self, candidates: List[int], target: int)</span> \</span></span><br><span class="line"><span class="function">            -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># important, we need it sorted</span></span><br><span class="line">        candidates.sort()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(nums: List[int], targ: int, start: int, store: List[int])</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">                <span class="comment"># test the number from `start` position</span></span><br><span class="line">                num = nums[i]</span><br><span class="line">                <span class="keyword">if</span> targ &lt; num:</span><br><span class="line">                    <span class="comment"># current number is gt current target, break</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># then we can append current number confidently</span></span><br><span class="line">                store.append(num)</span><br><span class="line">                <span class="keyword">if</span> targ == num:</span><br><span class="line">                    <span class="comment"># if equals, we find it, pop the number</span></span><br><span class="line">                    <span class="keyword">nonlocal</span> ans</span><br><span class="line">                    <span class="comment"># deep-copy, important detail</span></span><br><span class="line">                    ans.append(store[:])</span><br><span class="line">                    store.pop()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># keep testing next number from current position</span></span><br><span class="line">                backtrack(nums, targ - num, i, store)</span><br><span class="line">                <span class="comment"># pop current number and test sibling number</span></span><br><span class="line">                store.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, [])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> target,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                           List&lt;Integer&gt; list,</span></span></span><br><span class="line"><span class="function"><span class="params">                           List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; num) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(num);</span><br><span class="line">            <span class="keyword">if</span> (target == num) &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtrack(candidates, target - num, i, list, ans);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><p>Time complexity of this approach is <code>O(N*logN)</code>;</p><p>Space complexity is <code>O(N)</code>;</p><hr><p><a href="https://github.com/isudox/leetcode-solution/blob/master/docs/39.combination-sum.md" target="_blank" rel="noopener">GitHub Link</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Forgive my poor English, I just wanna improve my writing skill.</span><br><span class="line">So if I make some stupid mistakes in writing, forget about them.</span><br><span class="line">Let&apos;s focus on the code :)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/combination-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;39. Combination Sum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Medium&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://isudox.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://isudox.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-136 Single Number</title>
    <link href="https://isudox.com/2019/03/26/leetcode-136-single-number/"/>
    <id>https://isudox.com/2019/03/26/leetcode-136-single-number/</id>
    <published>2019-03-26T12:20:20.000Z</published>
    <updated>2019-03-29T14:10:09.596Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/single-number/solution/" target="_blank" rel="noopener">136. Single Number</a></p><p>Easy</p></blockquote><a id="more"></a><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><strong>Note:</strong></p><blockquote><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p></blockquote><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Actually it’s quite simple to solve, but we should make clear that it requires <code>O(N)</code> complexity and no extra memory usage. So we need to find out the single one during several iterations.<br>As is well-known,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a XOR a = 0</span><br><span class="line">0 XOR a = a</span><br></pre></td></tr></table></figure><p>So all the duplicate numbers will be calculated to <code>0</code> after looping xor, and the result of the iteration of xor must be the single number value.<br>Here is the sample code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">single_number</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># xor each sibling num</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a ^ b, nums)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><p>Time complexity of this approach is <code>O(N)</code>;<br>Space complexity is <code>O(1)</code>;</p><hr><p><a href="https://github.com/isudox/leetcode-solution/blob/master/docs/136.single-number.md" target="_blank" rel="noopener">GitHub Link</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Forgive my poor English, I just wanna improve my writing skill.</span><br><span class="line">So if I make some stupid mistakes in writing, forget about them.</span><br><span class="line">Let&apos;s focus on the code :)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number/solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;136. Single Number&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Easy&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="https://isudox.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://isudox.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6 和 Python 中的 Generator</title>
    <link href="https://isudox.com/2018/04/22/generators-in-python-es6/"/>
    <id>https://isudox.com/2018/04/22/generators-in-python-es6/</id>
    <published>2018-04-22T15:20:03.000Z</published>
    <updated>2019-03-26T15:34:13.430Z</updated>
    
    <content type="html"><![CDATA[<p>这几天折腾的一个 RSS 聚合爬虫，前端部分涉及到 <code>redux-saga</code>，对 ES6 里引入的 Generator 运用很花哨，看起来会云里雾里，其实和 Python 的 <code>generator</code>、<code>yield</code> 从思想上到写法上基本是一致的，之前也写过 Python 里的用法，这里也简单的写下我对动态语言里 <code>generator</code> 的学习和理解。</p><a id="more"></a><h2 id="通识"><a href="#通识" class="headerlink" title="通识"></a>通识</h2><p>首先，<code>generator</code> 本质上还是 <code>function</code>，只是行为略微特殊。<br>普通 <code>function</code> 会在执行结束时通过 <code>return</code> 返回；<br><code>generator</code> 可以中断 <code>function</code> 的执行过程，并重新回到断点现场继续执行。具体实现就是通过 <code>yield</code> 将结果返回给调用方并中断，通过 <code>next()</code> 方法继续回到断点再执行到下一个 <code>yield</code> 断点处。<br>普通函数只会返回一次，就是在执行结束的时候；<code>generator</code> 函数在执行过程中可以多次返回，即在 <code>yield</code> 断点处取代了 <code>return</code>。</p><p>还有一个和 <code>generator</code> 紧密相关的概念是 <code>iterator</code>，简单的描述二者的关系就是──<code>generator</code> 实现的目的是生成一个 <code>iterator</code>，它是 <code>iterable</code> 的，也就是说是可以循环遍历的。</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>JavaScript ES6 的 <code>generator</code> 和普通函数相比，最明显的不同在于它的关键字包含星号 <code>*</code> 和 <code>yield</code>，比如 MDN 文档上的代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="comment">// expected output: 20</span></span><br></pre></td></tr></table></figure><p>来看看上面的代码先后发生了什么──</p><ol><li><code>function* generator(i) {}</code> 代码块声明了一个 <code>generator</code>，此时什么都没发生；</li><li><code>var gen = generator(10)</code> 创建了一个 <code>generator</code> 并赋给变量 <code>gen</code>；</li><li>第一次调用 <code>gen.next().value</code> 时，执行了 <code>generator</code> 进入到第一个 <code>yield</code> 的地方，中断执行并返回 i，即 10；</li><li>第二次调用 <code>gen.next().value</code> 时，回到 <code>generator</code> 断点现场继续执行直到第二个 <code>yield</code> 再次中断并返回 i + 10，即 20；</li></ol><p>可以预料的，如果第三次调用 <code>gen.next().value</code> 得到的会是 <code>undefined</code>，因为这个 <code>generator</code> 在第二次调用时已经结束了所有断点完成了“生成”的任务。</p><p>注意到 <code>next()</code> 方法，它返回的是一个包含两个属性的 JSON 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: object,</span><br><span class="line">  done: boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 即 <code>generator</code> 创建的 <code>iterator</code> 里的元素，done 则表示该 <code>iterator</code> 是否结束。</p><p>再来看 <code>generator</code> 的经典场景，生成 Fibonacci 数列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator pattern</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genFib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> a = <span class="number">0</span></span><br><span class="line">  b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(b &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">yield</span> b</span><br><span class="line">      b = b + a</span><br><span class="line">      a = b - a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fib = genFib(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> fib) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由之前的过程分析，这个 Fibonacci 数列生成过程就非常好理解了。<br>换个写法，如果是普通的循环迭代生成 Fibonacci 数列，一般就是类似下面代码的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loop pattern</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genFib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> fib = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(b &lt;= n) &#123;</span><br><span class="line">    fib.push(b)</span><br><span class="line">      b = b + a</span><br><span class="line">      a = b - a</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fib</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看两者似乎只是写法上的不同，实际运行速度因为样本数量级太小也比较不出差异。但仔细观察，就不难发现，第二种循环迭代的写法会把结果全部存储在内存中，只有当它完全生成后，才会返回；而第一种生成器的写法，每次只会生成一个元素并立刻返回。当数量 n 很大时，<code>generator</code> 的资源和性能收益就很可观了。</p><p>JavaScript 就像一匹脱缰的野马，语法实在是太灵活了，有好多写法会让程序员觉得怪异，就比如 <code>yield*</code> 的用法，这个表达式其实是用来将一个 <code>generator</code> 委托给另一个 <code>generator</code>，笑 cry……</p><p>比如前面的例子里，<code>generator</code> 是赋给一个普通变量，而 <code>yield* [[expression]]</code> 则是将右侧表达式的 <code>generator</code> 的每个元素都做一次 <code>yield</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* gen1();</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...gen2()];</span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>JavaScript 内置的支持 <code>iterable</code> 的对象有 <code>String</code>，<code>Array</code>，<code>TypedArray</code>，<code>Map</code>，<code>Set</code>。所以这些内置对象也支持 <code>yield*</code> 表达式，<code>for-of</code> 表达式和 <code>...</code> 表达式，非常“灵活”。</p><p>理解了 JavaScript ES6 里的 <code>generator</code>，对 redux-saga 状态管理的理解就比较轻松了，后面有时间了再写关于 redux-saga 的内容。</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python 中的 <code>generator</code> 和 JavaScript 的实现基本是相同的。还是用 Fibonacci 举例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> b &lt;= n:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        b = b + a</span><br><span class="line">        a = b - a</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> gen_fib(<span class="number">100</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>Python 版本只是增加了 <code>yield</code> 关键字，并没有在函数声明的地方设计 <code>*</code> 来表征 <code>generator</code>。<br>之前的博客<a href="/2016/10/26/python-generator-guide/">理解 Python 生成器</a> 写的很浅，这里试着从 Magic Method 着手更深入的写写。</p><p>Python 内置了一些由双下划线包裹、被称为 Magic Method 的特殊方法，像常用的 <code>__init__</code>，<code>__new__</code>，<code>__str__</code>。这些 Magic Method 设计的初衷是为了描述对象的内在行为，而无需外部显性调用。比如我们声明一个对象，并编写它的 <code>__init__</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, author)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.author = author</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">book = Book(<span class="string">'Harry Potter'</span>, <span class="string">'J.K Rowling'</span>)</span><br><span class="line">book.__getattribute__(<span class="string">'name'</span>)</span><br><span class="line">book.__getattribute__(<span class="string">'author'</span>)</span><br></pre></td></tr></table></figure><p>我们并没有直接调用 <code>__init__</code> 方法，但 Python 解释能理解并调用 <code>__init__</code> 初始化对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天折腾的一个 RSS 聚合爬虫，前端部分涉及到 &lt;code&gt;redux-saga&lt;/code&gt;，对 ES6 里引入的 Generator 运用很花哨，看起来会云里雾里，其实和 Python 的 &lt;code&gt;generator&lt;/code&gt;、&lt;code&gt;yield&lt;/code&gt; 从思想上到写法上基本是一致的，之前也写过 Python 里的用法，这里也简单的写下我对动态语言里 &lt;code&gt;generator&lt;/code&gt; 的学习和理解。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://isudox.com/tags/JavaScript/"/>
    
      <category term="Python" scheme="https://isudox.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离实践</title>
    <link href="https://isudox.com/2017/12/29/frontend-backend-split-practice/"/>
    <id>https://isudox.com/2017/12/29/frontend-backend-split-practice/</id>
    <published>2017-12-29T02:44:59.000Z</published>
    <updated>2019-03-26T15:34:13.430Z</updated>
    
    <content type="html"><![CDATA[<p>整理中，待完善……</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理中，待完善……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 8 Stream API 和函数式编程</title>
    <link href="https://isudox.com/2017/07/12/java-8-streams-api-fp-intro/"/>
    <id>https://isudox.com/2017/07/12/java-8-streams-api-fp-intro/</id>
    <published>2017-07-12T03:10:03.000Z</published>
    <updated>2019-03-26T15:34:13.430Z</updated>
    
    <content type="html"><![CDATA[<p>流式操作我们在很多地方都使用过，比如 Shell 操作时经常用到的 <code>ps aux | grep xxx</code>、Python 中的 <code>mapreduce</code> 方法。Java 8 也引入了 Stream API，并且加入 Lambda 表达式，使得函数也可以成为像类一样的一等公民。</p><a id="more"></a><p>在引出主题前，先看一道简单的算法题，分别用 Java 和 Python 来实现。</p><blockquote><p>给定的一个整型数组，将其中每个元素变为它的平方。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">square</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer n : nums) &#123;</span><br><span class="line">            res.add(n * n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> nums]</span><br></pre></td></tr></table></figure><p>上面两个实现都是对这个问题最直接的解法，遍历数组中每个元素，同时计算其平方。对于 Python 的算法，如果了解过 lambda 表达式的话，还可以想出下面这种写法──</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, nums))</span><br></pre></td></tr></table></figure><p>而对于 Java，在 Java 8 以前是没办法像 Python 等脚本语言一样去处理的，但 Java 8 引入了 Stream API，使得 Java 也有了流式处理和 Lambda 表达式。因此，Java 解法可以这样写──</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">func</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.stream().map(n -&gt; n * n).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Stream API 一个直观的变化是，Java 代码更简洁了。</p><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>很多脚本语言都支持 Lambda 表达式，比如 JavaScript ES6 引入的箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="string">"Hydrogen"</span>, <span class="string">"Helium"</span>, <span class="string">"Lithium"</span>, <span class="string">"Beryl­lium"</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123; <span class="keyword">return</span> s.length &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a3 = a.map( <span class="function"><span class="params">s</span> =&gt;</span> s.length );  <span class="comment">// [ 8, 6, 7, 9 ]</span></span><br></pre></td></tr></table></figure><p>又比如上面 Python 代码里的 lambda 关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>在 Java 8 以前，如果想将行为传入方法中，往往是选择匿名类的方式。当匿名类的实现本身很简单，比如只有一个方法的接口，这种情况下匿名类的语法显得啰嗦、不清晰。Java 8 的 Lambda 表达式优化了匿名类里模板式的代码，其写法就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( [param,] [param,] ... ) -&gt; expression</span><br><span class="line">( [param,] [param,] ... ) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://o70e8d1kb.qnssl.com/lambda_sample.png" alt></p><p>它包含三部分：</p><ul><li>参数列表：由圆括号包裹、逗号分隔；</li><li>箭头符号： <code>-&gt;</code> 把参数列表和 Lambda 主体分隔开；</li><li>Lambda 主体：是实现匿名表达式逻辑的主要部分，返回了 Lambda 的结果。如果有返回类型，必须由花括号包裹，如果是返回 <code>void</code> ，则非必须；</li></ul><p>Lambda 表达式看起来非常像方法的声明，可以把它理解为是没有函数名的匿名函数。Lambda 表达式可以作为参数传递给方法或存储在 <code>FunctionalInterface</code> 变量中。</p><p><img src="https://o70e8d1kb.qnssl.com/lambda_sample2.png" alt></p><p>在什么场景中可以运用 Lambda 表达式？现在已经知道，Lambda 表达式的两种使用方式：</p><ul><li>赋值给函数式接口实例变量；</li><li>传递给接收函数式接口作为行为参数的方法；</li></ul><p>总结一下，实际上就是在需要函数式接口的编程场景中。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda 表达式可以作为参数递给方法，换句话说，Lambda 表达式本身可以作为方法的一个参数，它将行为参数化。<br><strong>函数式接口</strong>是只定义一个抽象方法的接口。Java API 提供了很多函数式接口，如常用的 <code>Runnable</code>、<code>Comparator</code>、<code>Predicator</code> 等（类似 <code>Comparator</code> 有两个抽象方法，但 <code>equals()</code> 方法在元类中有实现，因此函数式接口的实例会默认实现它），并给函数式接口加上了 <code>@FunctionalInterface</code> 注解。当开发者需要编写自定义的函数式接口时，可以使用 <code>@FunctionalInterface</code> 注解，如果代码不符合函数式接口的原则，则在编译期就会抛出错误。</p><p>函数式接口定义的抽象方法，可以理解为一个动作，比如 <code>Runnable</code> 的 <code>run()</code> 方法，定义了运行线程这个动作。而 Lambda 表达式实际上就是通过内联的形式为为函数式接口的抽象方法提供了具体实现，并把整个表达式作为函数式接口具体实现的实例。</p><p>参照数学里的函数 <code>y = f(x)</code>，函数式接口抽象方法可以抽取出这样一个函数描述符，比如前面提到的比较苹果的重量，就是 (Apple, Apple) -&gt; int，即接收两个 Apple 变量作为参数，返回 int 结果的函数。而 Lambda 表达式的函数描述符必然是和函数式接口抽象方法是一致的（也包括泛型）。比如下面的例子──</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proc</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line">proc(() -&gt; System.out.println(<span class="string">"Hello World!"</span>));</span><br></pre></td></tr></table></figure><p>其中的 Lambda 表达式的函数描述符是 <code>() -&gt; void</code>，和 <code>Runnable</code> 接口中的 <code>run()</code> 方法的函数描述符是相同的，因此它可以作为 <code>Runnable</code> 行为参数，传递到 <code>proc()</code> 方法中。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>对于仅是调用特定方法的 Lambda 表达式，Java 8 提供了<strong>方法引用</strong>简化了 Lambda 表达式。方法引用可以直接访问类或者实例的方法，使得现有的方法定义可以重复使用，并像 Lambda 一样传递它们，而且在可读性上更进一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line"></span><br><span class="line">list.sort(comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure><p>目标引用和目标方法由分隔符 <code>::</code> 分隔，例如上面的代码中，就是引用了 Apple 类中定义的 <code>getWeight()</code> 方法。方法引用是引用而非调用，所以方法名后是没有括号的。下面是 Lambda 及其等效方法引用的例子。</p><p><img src="https://o70e8d1kb.qnssl.com/lambda_method_reference.png" alt></p><p>方法引用主要有三类──</p><ul><li>指向静态方法的引用，如 String 的 <code>indexOf()</code> 方法，可以通过 <code>String::indexOf</code> 引用；</li><li>指向任意类型实例方法的引用，如 String 的 <code>length()</code> 方法，<code>String::length</code>；</li><li>指向现有对象的实例方法的引用，如 Apple 实例的 <code>getWeight()</code> 方法，<code>apple::getWeight</code>；</li></ul><p>三种使用方式举例如下──</p><p><img src="https://o70e8d1kb.qnssl.com/lambda_method_reference_usage.png" alt></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="取代匿名类"><a href="#取代匿名类" class="headerlink" title="取代匿名类"></a>取代匿名类</h3><p>如果在当前方法中新起一个线程去执行一个任务，通常的做法是通过实现 Runnable 的匿名类，它至少是需要 6 行代码，而其中具体行为代码只有 1 行，其他都是模板代码；而 Lambda 表达式来实现，只需要一行代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before Java8, too much code for too little to do"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"In Java8, Lambda expression rocks !!"</span>)).start();</span><br></pre></td></tr></table></figure><p>再举一个经常使用的栗子，对 Comparator 匿名类的使用和 Lambda 表达式的改进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(persons, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Collections.sort(persons, (o1, o2) -&gt; o1.getAge().compareTo(o2.getAge()));</span><br></pre></td></tr></table></figure><h3 id="对集合迭代"><a href="#对集合迭代" class="headerlink" title="对集合迭代"></a>对集合迭代</h3><p>Stream API 和 Lambda 表达式的引入对 Java 集合的操作产生了很大影响（尤其是 Stream API）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Python"</span>, <span class="string">"Scala"</span>, <span class="string">"Haskell"</span>, <span class="string">"Smalltalk"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String e : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Python"</span>, <span class="string">"Scala"</span>, <span class="string">"Haskell"</span>, <span class="string">"Smalltalk"</span>);</span><br><span class="line">    list.forEach(e -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码里，简洁的优势体现的不十分明显，因为本身比较简单，而且也没有充分运用 Stream API。下面继续介绍 Stream API。</p><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>Java 8 为集合处理提供了新的 API──Stream API，Oracle 对 Stream 的<a href="http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html" target="_blank" rel="noopener">官方定义</a>是：</p><blockquote><p>A sequence of elements from a source that supports aggregate operations.</p></blockquote><ul><li>元素序列：流提供了一个接口，可以访问特定元素类型的一组有序值。和集合不同的是，流实际上不存储元素，它只是在需要的时候进行计算。而集合是数据结构，目的是以特定的时间/空间复杂度存储和访问元素。流侧重计算，集合侧重数据。</li><li>源：即数据源，流通过它来获取数据并作计算，如集合、数组、I/O 资源。</li><li>数据处理操作：流支持像 SQL 操作和函数式编程中的常用操作（filter, map, reduce, find, match, sorted 等）。</li><li>管道操作：很多流操作本身就返回流，因此多个操作可以组合成链式调用。</li><li>内部迭代：和集合的外部迭代不同，流的迭代操作是在内部完成的。</li></ul><p>先来看下 Java 7 和 Java 8 实现同一个功能的两种写法。有一组 Person 信息，要从中筛选出所有成年人的名字，并按年龄排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getAdultNamesInJava7</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; adults = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">            adults.add(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; adultName = Lists.newArrayList();</span><br><span class="line">    Collections.sort(adults, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1.getAge(), o2.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (Person p : adults) &#123;</span><br><span class="line">        adultName.add(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adultName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getAdultNamesInJava8</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> persons.stream()</span><br><span class="line">            .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">            .sorted(comparing(Person::getAge))</span><br><span class="line">            .map(Person::getName)</span><br><span class="line">            .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较上面的代码，使用 Stream API 实现的代码无论是代码简洁程度和可读性上，都比 Java 7 的实现好很多。Stream API 的特点就是：</p><ul><li>声明性──说明想完成什么，而不是说明如何实现，结合通过 Lambda 表达式传入的行为参数，代码简洁易读；</li><li>可复合──可以将多个基础操作连接成管道，来表达复杂的数据处理流水线；</li><li>可并行──流可以被并行处理，提升了性能；</li></ul><p>分析上面 Java 8 的代码，首先对集合（即源）调用 <code>stream()</code> 方法获得流，filter、sorted、map、collect 都是对流的数据处理操作。其中，filter、sorted、map 是返回 <code>Stream</code> 对象，因此这几个操作复合为一个管道。最后调用 collect 处理流水线，并返回处理结果。整个处理流程就是：</p><ul><li>filter──通过 Lambda 表达式描述的行为，对 Stream 进行筛选，选择年龄大于 18 的 Person；</li><li>sorted──接受 Lambda 表达式对 Stream 进行排序；</li><li>map──由 Lambda 表达式将 Person 转换为其他类型；</li><li>collect──将流转换为其他形式；</li></ul><h2 id="Stream-和-Collection"><a href="#Stream-和-Collection" class="headerlink" title="Stream 和 Collection"></a>Stream 和 Collection</h2><p>在使用 Java Collection 接口时，是开发者去实现迭代逻辑，比如 for-each 遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; adultName = Lists.newArrayList();</span><br><span class="line"><span class="keyword">for</span> (Person p : adults) &#123;</span><br><span class="line">    adultName.add(p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-each 显式迭代，并执行逻辑。而 Stream 是通过内部逻辑自行完成了迭代，只需要开发者提供声明性的语句告诉 Stream 该做什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; adultName = adults.stream()</span><br><span class="line">                               .map(Person::getName)</span><br><span class="line">                               .collect(toList());</span><br></pre></td></tr></table></figure><p>Stream API 内置了很多数据处理操作来实现复杂的查询处理，这些强大的 API 使迭代逻辑隐藏进了 Stream 内部。这是 Stream 和 Collection 显著的区别。</p><h2 id="Stream-API-的使用"><a href="#Stream-API-的使用" class="headerlink" title="Stream API 的使用"></a>Stream API 的使用</h2><p>前面的代码中，用到了一些 Stream API，可以将其分为两类：</p><ul><li>中间操作（Intermediate）：类似 filter、sorted、map、limit 等都是返回流，可以将复合成流水线；</li><li>终端操作（Terminal）：类似 collect 等真正执行流水线任务；</li></ul><p>中间操作只是把数据操作组合成一个查询，但并没有执行。数据处理的执行是在调用终端操作时开始。因此，流的使用包含三个部分：</p><ul><li>数据源，提供元素序列；</li><li>中间操作，复合成流水线；</li><li>终端操作，执行流水线，并生成结果；</li></ul><p>下表列出了常用的中间操作和终端操作。其中中间操作有状态有无之分，区别在于中间操作在元素上执行时是否需要知道其他任何元素。比如 <code>filter</code> 只需要关注当前元素是否符合筛选条件，<code>sorted</code> 则需要关注其他元素才能获得正确的顺序。</p><p><img src="https://o70e8d1kb.qnssl.com/java8_operations.png" alt></p><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">nums.stream().fitler(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">             .distinct()</span><br><span class="line">             .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><code>filter</code> 方法接受函数描述符为 T -&gt; boolean 的行为参数作为谓词，通过该行为参数来返回符合条件的元素的流。配合 <code>distinct</code> 筛选元素唯一的流，<code>limit</code> 方法则是截断流，<code>skip</code> 方法是跳过元素。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = adults.stream()</span><br><span class="line">        .map(Person::getName)</span><br><span class="line">        .collect(toList());</span><br></pre></td></tr></table></figure><p><code>map</code> 方法接受函数描述符为 T -&gt; R 的 <code>Function</code> 实例作为行为参数，该行为参数会作用到流里的每个元素上，并映射成 R 类型的新元素。</p><h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><p>Stream API 提供了 <code>allMatch</code>、<code>anyMatch</code>、<code>noneMatch</code>、<code>findFirst</code> 和 <code>findAny</code> 来实现对元素序列查找匹配的查询。<code>*Match</code> 方法接受返回布尔值的行为参数，查找结果为布尔值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (persons.stream().anyMatch(Person::isAdult)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"This person is an adult."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find*</code> 方法可能从流中查找到复合条件的元素，也可能查找不到，它返回 <code>Optional</code>，<code>Optional&lt;T&gt;</code> 是一个容器类，用来盛装存在或者不存在的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; adult = persons.stream()</span><br><span class="line">                                .filter(Person::isAdult)</span><br><span class="line">                                .findAny();</span><br></pre></td></tr></table></figure><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p><code>Optional</code> 可以让开发者避免 <code>NullPointerException</code> 的尴尬。在很多代码里，我们为了避免 NPE，会用防御性的检查 null 引用，如果一个对象的结构比较复杂，需要处理的属性嵌套比较深，null 检查会一层套一层……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Car car = person.getCar();</span><br><span class="line">    <span class="keyword">if</span> (car != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何一个可能为 null 的属性，都有检查的必要，这样的代码很强壮，但也很难看。<code>Optional</code> 的使用方式是，当变量可能存在也可能不存在时，就不应该声明为具体的类型，而是应该直接将其声明为 Optional<object> 类型。<br>当这个变量实际存在时，Optional<object> 会返回其值，当这个变量不存在时，则是返回 Optional.empty()，可以把它理解为 null，但它是真实有效的对象，不会产生 NPE。参考下面的实例：</object></object></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Car&gt; car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Car&gt; <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Insurance&gt; insurance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title">getInsurance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insurance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于既有的代码，比如从 Map&lt;String, Object&gt; 中获取 value，随时可能会得到 null，使用 <code>Optional</code> 封装 value，就可以避免 if-else 代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(<span class="string">"key"</span>));</span><br></pre></td></tr></table></figure><p>对代码中潜在值为 null 的对象，都可以通过 <code>Optional.ofNullable</code> 将其安全的转换为 Optional 对象。</p><p>对于执行方法过程中可能发生失败而捕获异常的 try-catch 代码块，也可以通过 Optional 让执行失败的方法返回 Optional 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(Integer.parseInt(str));</span><br><span class="line">&#125; <span class="keyword">catch</span>(NumberFormatException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合 Java 8 和 Optional 可以让代码更加简洁可读，而且 Optional 是在编译期就处理了 null 问题，避免问题留到运行时发现和解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.print(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional.ofNullable(text).map(String::length).orElse(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> text != <span class="keyword">null</span> ? text.length() : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p><code>reduce</code> 方法可以把流中的元素组合起来，给定一个初始值，然后依次对流中各个元素进行组合。例如元素求和、求均值、求 max/min 值等，实际上都是 <code>reduce</code> 操作。对于没有给定初始值的 <code>reduce</code> 操作，因为可能没有足够的元素，因此是返回 Optional 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; Integer.max(a, b));</span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);</span><br><span class="line">min.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>上面已经提到的方法中，都是从对集合调用 <code>stream</code> 方法得到流。还可以从值序列、数组、文件来创建流。<br><code>Stream.of()</code> 方法可以显式的创建一个流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>, <span class="string">"Action"</span>);</span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>实际上，<code>Stream.of</code> 本身是调用了 <code>Arrays.stream</code> 方法创建流，也就是可以用过数组创建流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure><p>对于文件操作，<code>java.nio.file.Files</code> 内置很多静态方法都会返回流。比如 <code>Files.lines</code> 方法将文件的各行转换成 String 流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询文件中出现了多少个不同的单词</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.lines(Paths.get(<span class="string">"data.txt"</span>), Charset.defaultCharset())</span><br><span class="line">                                 .flatMap(line -&gt; Arrays.stream(line.split(<span class="string">" "</span>)))</span><br><span class="line">                                 .distinct()</span><br><span class="line">                                 .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些场景里的流，在数学概念上是无限的，比如质数、勾股数对、斐波拿契数列等。它们不像从集合、文件创建流那样有固定的大小，Stream API 提供了 <code>iterate</code> 和 <code>generate</code> 方法来生成无限流。</p><p><code>iterate</code> 方法接受一个初始值和 Lambda 表达式，Lambda 表达式是作用在初始值和每次作用后的结果值上的一个函数，可以理解为 f(x)、 f(f(x))…比如创建一个偶数流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偶数列</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">      .limit(<span class="number">10</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fibonacci 数列</span></span><br><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, t -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;t[<span class="number">1</span>],t[<span class="number">0</span>] + t[<span class="number">1</span>]&#125;)</span><br><span class="line">                .limit(<span class="number">10</span>)</span><br><span class="line">                .forEach(t -&gt; System.out.println(t[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><p><code>generate</code> 方法接受函数式接口 <code>Supplier</code> 实例作为参数，由 <code>Supplier.get</code> 方法生成新的值。比如创建一个随机数流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机数列</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">Stream.generate(r::nextInt)</span><br><span class="line">        .limit(<span class="number">5</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fibonacci 数列</span></span><br><span class="line">IntSupplier fib = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldPrevious = <span class="keyword">this</span>.previous;</span><br><span class="line">        <span class="keyword">int</span> nextValue = <span class="keyword">this</span>.previous + <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.previous = <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.current = nextValue;</span><br><span class="line">        <span class="keyword">return</span> oldPrevious;</span><br><span class="line">    &#125; &#125;;</span><br><span class="line">IntStream.generate(fib).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>Stream API 相比传统的写法，除了在灵活性和可读性上的提升，还可以在对集合执行流水线操作时，充分利用多核性能，而不用去人为的去拆分数据，分配多线程，还要避免可能的对同一个资源的竞争。<code>parallelStream</code> 方法可以把数据源转化为并行流，或者调用 <code>Stream.parallel</code> 方法也可以创建并行流。反过来，并行流可以通过 <code>Stream.sequential</code> 方法转化为顺序流。</p><p>引入 JMH 对 Stream 和 Collection 进行基准测试。<br>对集合采用传统的迭代写法，和用 Stream API 的写法，在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line"><span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benchmarks</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; NUM = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        NUM = Stream.generate(r::nextInt)</span><br><span class="line">                .limit(SIZE)</span><br><span class="line">                .collect(toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; res = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : NUM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(Math.sqrt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NUM.stream()</span><br><span class="line">                .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                .map(Math::sqrt)</span><br><span class="line">                .collect(toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">pstream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NUM.parallelStream()</span><br><span class="line">                .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                .map(Math::sqrt)</span><br><span class="line">                .collect(toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options options = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(Benchmarks.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .warmupIterations(<span class="number">5</span>)</span><br><span class="line">                .measurementIterations(<span class="number">5</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(options).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Run complete. Total time: 00:00:48</span><br><span class="line"></span><br><span class="line">Benchmark           Mode  Cnt   Score    Error  Units</span><br><span class="line">Benchmarks.loop     avgt    5  19.292 ± 13.102  ms/op</span><br><span class="line">Benchmarks.pstream  avgt    5   8.188 ±  0.337  ms/op</span><br><span class="line">Benchmarks.stream   avgt    5  21.923 ± 13.496  ms/op</span><br></pre></td></tr></table></figure><p>从上面这个简单的基准测试结果中，大概能推断出，对于基本类型，在大数据量的操作时，Stream API 并行处理比传统的外部迭代在性能上有所提升。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>对 Stream API 的调试，IDEA 官方开发了一个 Plugin──<a href="https://plugins.jetbrains.com/plugin/9696-java-stream-debugger" target="_blank" rel="noopener">Java Stream Debugger</a> 来扩展 IDEA 中的 debug 工具。在 debug 的工具栏上增加了 Trace Current Stream Chain 按钮──<br><img src="https://blog.jetbrains.com/idea/files/2017/05/Screen-Shot-2017-05-11-at-15.06.58.png" alt><br>打开跟踪调试窗口，IDEA 用图像化的方式把数据源整个执行过程展示出来。<br><img src="https://blog.jetbrains.com/idea/files/2017/05/Screen-Shot-2017-05-11-at-15.06.18.png" alt></p><hr><p>参考资料：</p><ul><li><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">Java 8 实战</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">Java 8 中的 Streams API 详解</a></li><li><a href="http://www.infoq.com/cn/articles/java8-new-features-new-stream-api" target="_blank" rel="noopener">Java 8 新特性：全新的 Stream API</a></li><li><a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java 8 Lambda 表达式 10 个示例</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda Expressions</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流式操作我们在很多地方都使用过，比如 Shell 操作时经常用到的 &lt;code&gt;ps aux | grep xxx&lt;/code&gt;、Python 中的 &lt;code&gt;mapreduce&lt;/code&gt; 方法。Java 8 也引入了 Stream API，并且加入 Lambda 表达式，使得函数也可以成为像类一样的一等公民。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Java" scheme="https://isudox.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>扔掉鼠标，开始键盘流编程</title>
    <link href="https://isudox.com/2017/06/25/coding-with-keyboard-no-mouse/"/>
    <id>https://isudox.com/2017/06/25/coding-with-keyboard-no-mouse/</id>
    <published>2017-06-25T14:40:10.000Z</published>
    <updated>2019-03-26T15:34:13.429Z</updated>
    
    <content type="html"><![CDATA[<p>之前曾和朋友讨论，为什么很多程序员舍得买千元价位的键盘，却很少愿意买个同级别的鼠标……最后一致认为原因在于代码是键盘敲出来的，不是鼠标点出来的。如果以后编程简化到拖拽下控件就搞定，那价值天平恐怕就能向鼠标倾斜了。</p><a id="more"></a><p>在开始尝试键盘流编程前，需要达成一个共识──</p><blockquote><p>不依赖鼠标的编程，不仅很酷，更重要的是非常高效。</p></blockquote><p>以 Java 编程来说，我使用的软硬件是 MacBook Pro、IntelliJ IDEA、Vim。脱离鼠标编程的关键在于──</p><ul><li>熟悉代码定位的快捷键，包括目标文件的打开，方法定义/实现的跳转等；</li><li>熟悉文档操作的快捷键，复制粘贴是最最基础的，复杂高阶的甚至可以是宏操作；</li></ul><p>纯熟的掌握以上两个技能，基本可以实现不依赖鼠标，双手不离开键盘地进行编程了。而 MacBook + IntelliJ IDEA + Vim 的组合工具最大化的降低了上述两点的习得门槛。为什么下这样的结论，其一，macOS 常用的组合键是 <code>Command</code> 键，这样就释放了大量潜在的以 <code>Control</code> 键为基础的快捷键，此外 macOS 支持 Emacs 的光标移动快捷键，这非常高效；其二，IntelliJ IDEA 是最棒的 Java IDE 没有之一，它的快捷键也是最出色的；其三，Vim 是久经考验的编辑器之神。</p><p>吹工具的话到此为止，下面就具体写写怎么用这些工具实现键盘流编程。</p><p>IDEA 本身并不支持 Vim 操作，需要安装一个堪称神器的插件 IdeaVim，几乎可以说是模拟 Vim 最好的一个插件了。IDEA 的完善快捷键加上 Vim 强大的文本编辑能力，多加练习就完全可以脱离对鼠标的依赖。</p><p>先来看 IDEA 自带的快捷键，哪些能带来强大的生产力。</p><h2 id="IDEA-键盘流"><a href="#IDEA-键盘流" class="headerlink" title="IDEA 键盘流"></a>IDEA 键盘流</h2><h3 id="快速定位文档"><a href="#快速定位文档" class="headerlink" title="快速定位文档"></a>快速定位文档</h3><p>IDEA 通过连续点击两次 <code>Shift</code> 键可以打开全局文件查找和最近访问文件查找；<br>在文件查找框中输入 <code>/</code> + 文件夹名，可以定位到文件夹所在位置；<br>通过 <code>Command</code> + <code>E</code> 打开最近访问文件的查找框；<br>通过 <code>Command</code> + <code>Shift</code> + <code>O</code> 查找文档名，精确定位文档；<br>在选择文档时，你根本不需要移动鼠标去点击，扔掉鼠标，试着用 <code>Ctrl</code> + <code>N</code> (<code>P</code>, <code>F</code>, <code>B</code>) 来对光标进行向下、向上、向前和向后移动。</p><h3 id="快速打开工具"><a href="#快速打开工具" class="headerlink" title="快速打开工具"></a>快速打开工具</h3><p>IDEA 内置了很多有用的工具和优化动作，比如 Console、 Rest Client、智能优化 import 和填充 Getter Setter 等，如果用鼠标去找再去一个个点真的很费劲，可以通过 IDEA 的全局动作搜索功能进行查找，快捷键是 <code>Command</code> + <code>Shift</code> + <code>A</code>，在搜索框中输入工具或动作的关键字就能定位到，自己尝试下吧，非常强大！</p><h3 id="全局查找修改"><a href="#全局查找修改" class="headerlink" title="全局查找修改"></a>全局查找修改</h3><p>有时候需要全局的查找关键字和修改，<code>Command</code> + <code>Shift</code> + <code>F</code> 全文搜索，更强大的是，IDEA 支持对文件名/变量名重命名而不影响引用关系，试试 <code>Shift</code> + <code>F6</code> 吧。</p><h2 id="IdeaVim-键盘流"><a href="#IdeaVim-键盘流" class="headerlink" title="IdeaVim 键盘流"></a>IdeaVim 键盘流</h2><p>对 Vim 熟悉的开发者，很多都会在其他编辑器和 IDE 中引入 Vim 的编辑模式，因为 Vim 实在是太好用了，我的理解是，Vim 其实不只是一款编辑器，它更是一种编辑的思想，及时脱离了 Vim 编辑器本身，很多 Vim 爱好者也会习惯于并认同使用 <code>h</code>、 <code>j</code>、 <code>k</code>、 <code>l</code> 键移动光标。</p><p>在 IntelliJ IDEA 中启用 Vim 模式后，会有一些快捷键冲突，主要是内置的几个 <code>Ctrl</code> 快捷键和 Vim 模式冲突，但冲突的键不多也很好解决，这个我在之前的博客中已经提供了参考方案。</p><p>Vim 的学习曲线有点陡，很多快捷键的记忆并不很直观，关于 Vim 操作的介绍可以写一本书，我掌握的水平也就是小半瓶水，但已经足够我在文本编辑时体会到快速和便利了。下面说几个操作抛砖引玉吧。</p><h3 id="光标的快速移动"><a href="#光标的快速移动" class="headerlink" title="光标的快速移动"></a>光标的快速移动</h3><p>在文件中如果要快速移动光标，大多数人会觉得用鼠标肯定打打快过键盘啊，毕竟鼠标指哪打哪。但写代码和浏览网页不同的地方在于，写代码时要定位一个位置往往是有目的性的，比如我就想跳转到某一行，我就想跳转到方法的结尾，类似这样的场景，鼠标其实不太好用，因为我还得要用眼睛去找，再移动鼠标去点击到那个位置，看似快实则慢。Vim 的话就会非常方便，比如我想让光标往下移动 12 行，就是通过敲键盘数字 12 和 <code>j</code> 键；<code>gg</code> 跳转到文件首行，<code>G</code> 跳转到文件末行；数字 n + <code>G</code> 跳转到第 n 行；<code>%</code> 跳转到当前括号的另一半对应位置……还有很多非常使用编程常用操作，不一一举例了。</p><p>Vim 的复制/剪切/粘贴也很方便，关键在于习惯 Vim 模式，脱离使用了多年的 <code>Ctrl</code> + <code>C</code>。键盘流编程并不难，至少我在使用 IDEA + Vim 并主观的尽量不用鼠标一段时间后，能明显感到编码更顺畅了，双手不用离开键盘确实能带来非常好的 Coding 体验，值得为此努力尝试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前曾和朋友讨论，为什么很多程序员舍得买千元价位的键盘，却很少愿意买个同级别的鼠标……最后一致认为原因在于代码是键盘敲出来的，不是鼠标点出来的。如果以后编程简化到拖拽下控件就搞定，那价值天平恐怕就能向鼠标倾斜了。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Vim" scheme="https://isudox.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 那些事儿</title>
    <link href="https://isudox.com/2017/05/24/spring-aop-guide/"/>
    <id>https://isudox.com/2017/05/24/spring-aop-guide/</id>
    <published>2017-05-24T11:25:56.000Z</published>
    <updated>2019-03-26T15:34:13.429Z</updated>
    
    <content type="html"><![CDATA[<p>AOP 即 Aspect-Oriented Programming，<strong>面向切面编程</strong>，是对 OOP 编程思想的补充。OOP 核心是继承、封装、多态，是实现 OOP 模块化的基础。当 OOP 达到一定规模后，对于遍布各处的横向代码的处理就开始捉襟见肘，而 AOP 正好弥补了这个不足。</p><a id="more"></a><h2 id="引入-AOP"><a href="#引入-AOP" class="headerlink" title="引入 AOP"></a>引入 AOP</h2><p>下图是很常见的编程场景──</p><p><img src="https://o70e8d1kb.qnssl.com/redundant_code.png" alt="redundant code"></p><p>我们经常会遇到需要在多个方法中实现相同的一部分功能，面向过程的办法就是像图示在每个方法里都复制粘贴相同的一段代码，但是如果要改动就要改动 N 处代码。在有了 OOP 思想后，我们就进阶了一大步，可以将相同的代码段抽离出来，避免了到处改动的问题。</p><p><img src="https://o70e8d1kb.qnssl.com/clean_code.png" alt="clean code"></p><p>一般像上图去实现代码就能应付大多数场景了。但随着软件规模的升级，有些问题就开始凸显了。首先共同功能的实现需要在各个方法中显示的去调用；其次，共同功能的控制权分散在代码各处；再次，对共同功能的依赖加重了类之间的耦合，降低了可重用性，如果共同功能并非各个方法的核心功能，那么就不应该耦合进各个对象中。AOP 则可以解决这些问题。</p><p>AOP 把系统功能分为两部分：<strong>核心关注点</strong>，<strong>横切关注点</strong>。核心关注点是代码的主要逻辑；横切进多个模块，但不是模块主要逻辑的就是横切关注点。不是简单的把公共模块抽离出来，而是把那些与具体业务无关的，却为业务模块所共同调用的逻辑或责任封装起来，减少冗余代码，降低模块间耦合度，提升可维护性。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p>《Sping 实战》中对 AOP 有一段非常形象的描述──</p><blockquote><p>每家每户都需要用电，电力公司会安装电表会记录用电量，会派员工查电表。但是如果没有电表也没有人来查看用电量，相信大多数家庭都不会去记录电量并缴费，因为这不是家庭重点关注的问题。软件开发中，类似记录用电量这种散布于应用中多处的功能被称为<strong>横切关注点</strong>（cross-cutting concern），从概念上是与应用的业务逻辑相分离的（但往往会直接嵌入到业务逻辑中）。把横切关注点与业务逻辑相分离正是 AOP 所要解决的问题。</p></blockquote><p>知道 AOP 大致是做什么的后，再来了解下 AOP 的专用术语：</p><ul><li>切面 Aspect：横切关注点模块化的类；</li><li>连接点 Join point：程序的执行点，比如方法的执行，或者异常的处理。在 Spring AOP 中，连接点总是表示方法执行；</li><li>通知 Advice：切面在某个具体的连接点上执行的动作。且可以定义动作执行的时机，比如 <code>around</code>、<code>before</code>、<code>after</code> 等。包括 Spring 在内的许多 AOP 框架，都会把通知模块化成拦截器，围绕连接点构建拦截链；</li><li>切点 Poincut：匹配通知所要执行的一个或多个连接点。通常明确指定或者使用正则表达式匹配类名.方法。</li><li>引入 Introduction：即向已有的类添加新方法或属性。Spring AOP 允许向被通知的类添加新的接口（和其实现）。</li><li>目标对象 Target objection：被一个或多个切面通知的类。因为在 Spring 中，AOP 是通过运行时代理实现的，所以目标对象总是代理对象。</li><li>AOP 代理：由 AOP 框架创建的为实现 aspect 的对象，在 Spring 中，AOP 代理是 JDK 动态代理或 CGLIB 代理。</li><li>织入 Weaving：把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。织入可以在对象生命周期的编译期、类加载期、运行期完成。Spring AOP 因为采用动态代理，所以是在<strong>运行期</strong>完成织入。</li></ul><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterServiceImpl</span> <span class="keyword">implements</span> <span class="title">PrinterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Your message: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"execution(* com.isudox.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Job completed time: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事物切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.isudox.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transact</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----Transaction begins----"</span>);</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"----Transaction end----"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-aop-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.isudox"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-aop-config.xml"</span>);</span><br><span class="line">        PrinterService printer = ctx.getBean(<span class="string">"printerServiceImpl"</span>, PrinterService.class);</span><br><span class="line">        printer.run(<span class="string">"Hello AOP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----Transaction begins----</span></span><br><span class="line"><span class="comment">// Your message: Hello AOP</span></span><br><span class="line"><span class="comment">// ----Transaction end----</span></span><br><span class="line"><span class="comment">// Job completed time: Thu Jun 01 16:27:37 CST 2017</span></span><br></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>AOP 有多种实现方案，比如 <a href="http://www.eclipse.org/aspectj/" target="_blank" rel="noopener">AspectJ</a> 和 Spring AOP。前者需要安装 AspectJ 扩展库，在编译器生成 AOP 代理类，后者则是在运行时动态生成代理类。总之，AOP 的实现是基于代理模式，所以先简单介绍下这种经典的设计模式。</p><blockquote><p>通过在代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。如下图所示，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean。当代理拦截到方法调用时，在调用目标 bean 方法之前，会执行切面逻辑。</p></blockquote><p><img src="https://o70e8d1kb.qnssl.com/aop-proxy.png" alt="aop proxy model"></p><p>Spring AOP 的实现本质上是采用了代理模式。</p><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。──GoF《设计模式》</p></blockquote><p>通俗的解释下代理模式，比如以前玩魔兽世界，如果华南区玩家直接玩华北区的服务器延迟会很高，于是就有了各种游戏代理服务器，通过走代理直连游戏服务器可以有效缓解高延迟问题，还有 FQ 代理也是同样的道理。运用代理模式的目的是<strong>对其他对象提供一种代理以控制对这个对象引用的访问</strong>，这样设计的好处是，可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。</p><p>代理模式包含 4 种角色，参考如下 UML 图：</p><ul><li>主题接口：代理类和真实对象所实现的共同接口；</li><li>真实对象：被代理的对象，即实际引用的对象；</li><li>代理对象：封装了真实对象的代理类，并提供与真实对象相同的接口以便随时代替真实对象，同时可以对真实对象的操作进行加强；</li><li>客户端：代理对象的调用者；</li></ul><p><img src="https://o70e8d1kb.qnssl.com/proxy-uml.png" alt="代理模式 UML"></p><p>根据代理类的生成时期，可以分为静态代理和动态代理，静态代理是在编译期生成代理类的 <code>.class</code> 文件，动态代理是在运行时通过反射动态生成代理类。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>参考 UML 图，我们可以用 Java 写一个简单的静态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manager 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String param)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的 Manager 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentManager</span> <span class="keyword">implements</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Today Plan: "</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manger 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerProxy</span> <span class="keyword">implements</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Manager manager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManagerProxy</span><span class="params">(Manager manager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager.handle(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Manager manager = <span class="keyword">new</span> DepartmentManager();</span><br><span class="line">        Manager proxy = <span class="keyword">new</span> ManagerProxy(manager);</span><br><span class="line">        proxy.handle(<span class="string">"Monthly Review"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----console output:-----</span></span><br><span class="line">    <span class="comment">// Today Plan: Monthly Review</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子演示了代理模式的一个基本实现，不过有人可能会产生疑问，如果只是简单地让 Department Manager 去做一件事，为什么要费劲创建一个代理类去完成，这不是舍近求远吗？前面讲到了，代理模式的目的是为了控制对目标对象的引用，也就是说，如果对目标对象的需求有所变动，遵循开闭原则不应该直接修改目标对象的代码，通过代理类就能不侵入的实现。以上面的代码为例，如果 Department Manager 需要在制定今日任务前输出 Manger 的职位，在制定任务后输出日期，在代理模式下，只需要对 Proxy 略微做修改即可改变真实对象引用的行为。修改后的代码如下──</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerProxy</span> <span class="keyword">implements</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Manager manager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManagerProxy</span><span class="params">(Manager manager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        preHandle();</span><br><span class="line">        <span class="keyword">this</span>.manager.handle(param);</span><br><span class="line">        postHandle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Position: "</span> + manager.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----console output:-----</span></span><br><span class="line">    <span class="comment">// Position: DepartmentManager</span></span><br><span class="line">    <span class="comment">// Today Plan: Monthly Review</span></span><br><span class="line">    <span class="comment">// 2017/05/24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理有其不足的地方，如果有 N 个真实对象，就需要指定 N 个代理类来代理；如果主题接口增加了方法，那么所有实现类和代理类都需要实现这个新方法。这无疑增加了代码维护的难度。另外，如果事先并不知道被代理的真实对象是什么，该如何实现代理。动态代理可以代理多个真实对象，并且可以动态指定，虽然在程序性能上不如静态代理，但在灵活性上显著优于静态代理。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>创建动态代理的方式有多种，可以通过 JDK 内置的 <code>java.lang.reflect</code> 包、<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 实现。JDK 实现动态处理相对简单，核心是利用反射，先介绍 JDK 的动态代理实现。</p><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>JDK 实现动态代理的过程如下：</p><ol><li>在运行期通过反射创建实现主题接口的代理类；</li><li>代理类的字节码将在运行时生成并载入当前代理的 ClassLoader，运行时生成的 class，需要提供真实对象的一组接口，然后该 class 就标示已实现这一组接口，但此时创建的代理类还只是空壳，没有代理的实际作用，因为只是对外声称实现了接口，实际并没有；</li><li>接口所声明的方法都会委托给调用处理器 <code>InvocationHandler</code> 作统一处理，每个方法的调用都会经过 <code>InvocationHandler.invoke()</code> 方法，实现了对真实对象方法的调用，而无需对每一个方法都做一个实现；</li></ol><p>这个过程主要涉及下面两个类：</p><ul><li><code>java.lang.reflect.Proxy</code>：提供 <code>Proxy.newProxyInstance()</code> 生成代理类；</li><li><code>java.lang.reflect.InvocationHandler</code>：调用处理器，是一个接口，执行真实对象的方法时，会出发调用处理器的方法，动态生成的代理类需要完成的具体任务由调用处理器的实现来处理；</li></ul><p><code>Proxy.newProxyInstance()</code> 第一个参数是加载该代理类到 JVM 的类加载器；第二个参数是代理类需要实现的接口；第三个参数是调用处理器的实现。方法源码精简如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由类加载器和接口创建指定的代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, interfacess);</span><br><span class="line">    <span class="comment">// 获得代理类的带参构造函数</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(<span class="keyword">new</span> Class[] &#123;InvocationHandler.class&#125;);</span><br><span class="line">    <span class="comment">// 创建代理对象实例，参数为调用处理器</span></span><br><span class="line">    <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InvocationHandler</code> 中只有一个 <code>invoke()</code> 方法，第一个参数是代理类实例；第二个参数是被调用的方法；第三个参数是被调用方法的入参──</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure><p>实现一个动态代理的简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Manager manager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicProxyy</span><span class="params">(Manager manager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                manager.getClass().getClassLoader(),</span><br><span class="line">                manager.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        preHandle();</span><br><span class="line">                        Object result = method.invoke(manager, args);</span><br><span class="line">                        postHandle();</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Position: "</span> + manager.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态代理测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProxyInstant</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Manager manager = <span class="keyword">new</span> DepartmentManager();</span><br><span class="line">        System.out.println(manager.getClass());</span><br><span class="line"></span><br><span class="line">        Manager proxy = (Manager) <span class="keyword">new</span> JdkDynamicProxyy(manager).getProxyInstant();</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line"></span><br><span class="line">        proxy.handle(<span class="string">"Monthly Review"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----console output----</span></span><br><span class="line">    <span class="comment">// class com.isudox.proxy.DepartmentManager</span></span><br><span class="line">    <span class="comment">// class com.sun.proxy.$Proxy4</span></span><br><span class="line">    <span class="comment">// Position: DepartmentManager</span></span><br><span class="line">    <span class="comment">// Today Plan: Monthly Review</span></span><br><span class="line">    <span class="comment">// 2017/05/24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，创建的动态代理类工作正常。</p><h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h4><p>CGLIB 又被称作子类代理，它的动态代理实现方式是通过转换字节码生成新的子类，从而扩展真实对象的功能。当需要被代理的真实对象是单纯的类时，就可以使用 CGLIB 子类代理来实现动态代理，当然对接口实现类也同样支持。</p><p>CGLIB 包下有 <code>MethodInterceptor</code> 接口，起到拦截方法调用的作用。CGLIB 动态代理类需要实现该接口，重写 <code>intercept()</code> 方法，把被调用的方法和入参传入给真实对象。</p><p>还用到 CGLIB 包下的 <code>Enhancer</code> 类，通过 <code>setSuperclass()</code> 设置父类，通过 <code>setCallback()</code> 设置回调方法，类似 <code>Proxy</code> 的 <code>invoke()</code> 方法。</p><p>参考下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CGLIB 动态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibDynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Object[] objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        preHandle();</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);  <span class="comment">// 调用父类即被代理类的方法</span></span><br><span class="line">        postHandle();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Position: "</span> + target.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY/MM/dd"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">intercept</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Manager manager = <span class="keyword">new</span> DepartmentManager();</span><br><span class="line">        System.out.println(manager.getClass());</span><br><span class="line"></span><br><span class="line">        Manager proxy = (Manager) <span class="keyword">new</span> CglibDynamicProxy(manager).getProxyInstant();</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line"></span><br><span class="line">        proxy.handle(<span class="string">"Monthly Review"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----console output----</span></span><br><span class="line">    <span class="comment">// class com.isudox.proxy.DepartmentManager</span></span><br><span class="line">    <span class="comment">// class com.isudox.proxy.DepartmentManager$$EnhancerByCGLIB$$56f0605c</span></span><br><span class="line">    <span class="comment">// Position: DepartmentManager</span></span><br><span class="line">    <span class="comment">// Today Plan: Monthly Review</span></span><br><span class="line">    <span class="comment">// 2017/05/24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，代码里的 <code>proxy</code> 实例是被代理的真实对象的子类，这是和 JDK 动态代理明显不同的地方，因此 CGLIB 可以实现对非接口实现类的动态代理。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对代理模式做个简单的小结──</p><ol><li>Subject 定义 ReaelSubject 和 Proxy 的公共接口，目的是让 Proxy 可以代替 RealSubject；</li><li>RealSubject 定义被代理的目标实体；</li><li>Proxy 会需持有目标对象的引用，使得代理可以访问到目标实体；</li><li>Proxy 对外提供和目标对象接口一致的实现，即直接通过代理替代目标实体；</li></ol><h2 id="Spring-AOP-实现"><a href="#Spring-AOP-实现" class="headerlink" title="Spring AOP 实现"></a>Spring AOP 实现</h2><p>在了解了动态代理的实现过程后，就可以深入源码对 Spring AOP 的实现原理一探究竟了。引用官方文档里的一段话──</p><blockquote><p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any <strong>interface (or set of interfaces)</strong> to be proxied.<br>Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. CGLIB is used by default if a business object <strong>does not implement an interface</strong>.</p></blockquote><p>简单地说，Spring AOP 对接口实现的类，默认采用 JDK 动态代理；对没有实现接口的类，则默认采用 CGLIB 实现动态代理。Spring 会自行判断，无需开发者人为去选择。</p><h3 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h3><p>还是参考本文开头的 Spring AOP 示例代码，在执行 <code>run()</code> 方法处加断点 debug，可以看到 <code>PrinterService</code> 实例是代理对象实例：</p><p><img src="https://o70e8d1kb.qnssl.com/spring-aop-breakpoint.jpeg" alt></p><p>因为目标对象实现了接口，Spring AOP 使用了内部封装的 <code>JdkDynamicAopProxy</code> 类实现动态代理，底层还是 JDK 动态代理。来看下它的源码──</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code> 无需赘述了，先来看 <code>AopProxy</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 AopProxy 默认的类加载器获取新的代理对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 通过指定的类加载获取新的代理对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>JdkDynamicAopProxy</code> 对 <code>AopProxy</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="comment">// 调用 JDK Proxy 生成代理对象实例</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考前文讲的 JDK 动态代理，<code>Proxy.newProxyInstance()</code> 方法传入类加载器，被代理的接口，以及 InvocationHandler 实现，生成动态代理对象的实例。</p><p><code>JdkDynamicAopProxy</code> 中对 <code>InvocationHandler.invoke()</code> 的实现本质上和前面的实例代码也是一样的。</p><h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><p>从源码中还能看到，在 Spring AOP 中，<code>AopProxy</code> 还有一个实现，就是 <code>CglibAopProxy</code>，这个类封装了 CGLIB 创建动态代理的实现。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇怪的是，这似乎和之前自己实现的 <code>CglibDynamicProxy</code> 不一样，它没有实现 CGLIB 的 <code>MethodInterceptor</code>。这里有一点需要注意，代理类实例实际上是由 <code>Enhancer.create()</code> 生成的，而在构建 <code>Enhancer</code> 实例时，需要通过 <code>Enhancer.setCallback()</code> 设置回调方法，这个回调方法是 <code>MethodInterceptor</code> 的具体实现。所以只需要将回调方法实现 <code>MethodInterceptor</code> 即可。具体看源码是怎么做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置 CGLIB Enhancer</span></span><br><span class="line">    Enhancer enhancer = createEnhancer();</span><br><span class="line">    enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取回调方法，即 MethodInterceptor 的实现</span></span><br><span class="line">    Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 生成代理类并创建代理实例</span></span><br><span class="line">  <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">    enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 在这设置了回调方法 callbacks</span></span><br><span class="line">    enhancer.setCallbacks(callbacks);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> ?</span><br><span class="line">            enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span><br><span class="line">            enhancer.create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以发现，<code>CglibDynamicProxy</code> 是通过调用 <code>getCallbacks()</code> 来获取回调方法的，再看它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Choose an "aop" interceptor (used for AOP calls).</span></span><br><span class="line">  Callback aopInterceptor = <span class="keyword">new</span> DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DynamicAdvisedInterceptor</code> 确实是实现了 <code>MethodInterceptor</code>。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q: 为什么 JDK 只能动态代理接口实现类，而不能对类创建动态代理？<br>A: 因为 Java 是单继承的，每个代理类都继承了 Proxy 类，因此不能对类创建代理类，只能对接口实现类。</p><p>Q: JDK 如何确保对代理对象方法的调用都会经过调用处理器 <code>InvocationHandler.invoke()</code> 方法？<br>A: JDK 在创建动态代理类时，内部的过程可以简单理解为下面的过程，所以只要是对代理类方法的调用，都会经过 <code>invoke()</code> 处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler h;</span><br><span class="line">    <span class="keyword">private</span> $Proxy1() &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler h) &#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        Method method = Subject.class.getMethod(<span class="string">"request"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">int</span>.class&#125;);</span><br><span class="line">        <span class="keyword">return</span> (Integer) h.invoke(<span class="keyword">this</span>, method, <span class="keyword">new</span> Object[] &#123;<span class="keyword">new</span> Integer(i)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Q: 代理模式和装饰器模式的区别？<br>A: 这两种设计模式非常相似，都是用一个类包装目标类，但在使用目的上有些许不同。代理模式侧重增强对目标对象的控制，装饰器模式侧重对目标对象的增强。</p><hr><p>参考资料：</p><ul><li><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">Spring 实战</a></li><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Spring Docs</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AOP 即 Aspect-Oriented Programming，&lt;strong&gt;面向切面编程&lt;/strong&gt;，是对 OOP 编程思想的补充。OOP 核心是继承、封装、多态，是实现 OOP 模块化的基础。当 OOP 达到一定规模后，对于遍布各处的横向代码的处理就开始捉襟见肘，而 AOP 正好弥补了这个不足。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Java" scheme="https://isudox.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://isudox.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Thrift 学习笔记：RPC Server 和 Client</title>
    <link href="https://isudox.com/2017/04/10/thrift-notes-server-client/"/>
    <id>https://isudox.com/2017/04/10/thrift-notes-server-client/</id>
    <published>2017-04-10T03:46:23.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p>在了解 Thrift IDL 后，就能开始编写自己的 RPC 服务端和客户端了。对 Thrift 的安装过程和命令操作略过不表，主要还是关注如何利用 Thrift 实现 Java 的 RPC 服务端和客户端。</p><a id="more"></a><h2 id="服务接口描述"><a href="#服务接口描述" class="headerlink" title="服务接口描述"></a>服务接口描述</h2><p>首先需要定义服务接口描述，即 <code>.thrift</code> 文件，再由 Thrift 将接口描述文件编译成相应的客户端和服务端的 stub 代码。</p><p>官网 Tutorial 给出的示例略复杂，不妨自己写一个简单的 Hello World 文件：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// tutorial.thrift</span><br><span class="line">namespace java com.isudox.thrift.tutorial</span><br><span class="line"></span><br><span class="line">typedef i32 int</span><br><span class="line"></span><br><span class="line">service CustomService &#123;</span><br><span class="line">    int add(1:int a, 2:int b)</span><br><span class="line">    string sayHello(1:string name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述文件写的很简单，只定义了一个接口，包含两个函数。将 <code>tutorial.thrift</code> 编译成 Java 代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -r --gen java tutorial.thrift</span><br></pre></td></tr></table></figure><p>生成如下 Java 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gen-java</span><br><span class="line">└── com</span><br><span class="line">    └── isudox</span><br><span class="line">        └── thrift</span><br><span class="line">            └── tutorial</span><br><span class="line">                └── CustomService.java</span><br></pre></td></tr></table></figure><p>下面是 <code>CustomService.java</code> 的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.isudox.thrift.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"cast"</span>, <span class="string">"rawtypes"</span>, <span class="string">"serial"</span>, <span class="string">"unchecked"</span>, <span class="string">"unused"</span>&#125;)</span><br><span class="line"><span class="meta">@javax</span>.annotation.Generated(value = <span class="string">"Autogenerated by Thrift Compiler (0.10.0)"</span>, date = <span class="string">"2017-04-10"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">sayHello</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后面省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Thrift 自动生成了接口 <code>CustomService.Iface</code>，包含 add() 和 sayHello() 函数。</p><p>另外，如果是 Maven 构建的项目，在模块的 <code>pom.xml</code> 文件中添加 Thrift 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了上面的编译后的 stub 代码，就能对 RPC 服务端和客户端具体实现进行编码了。</p><h2 id="Server-amp-Client"><a href="#Server-amp-Client" class="headerlink" title="Server &amp; Client"></a>Server &amp; Client</h2><p>在编写 RPC Server 和 Client 代码前，得先把 Thrift 定义的接口实现。编写 <code>CustomServiceHandler.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CustomServiceHandler.java</span></span><br><span class="line"><span class="keyword">package</span> com.isudox.thrift.tutorial</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomServiceHandler</span> <span class="keyword">implements</span> <span class="title">CustomService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> a + b;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就能编写 Server 和 Client 的具体实现了，通过 <code>CustomServiceHandler</code> 来实现远程调用；</p><p><code>CustomServer.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CustomServer.java</span></span><br><span class="line"><span class="keyword">package</span> com.isudox.thrift.tutorial</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CustomServiceHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CustomService.Processor processor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> CustomServiceHandler();</span><br><span class="line">            processor = <span class="keyword">new</span> CustomService.Processor(handler);</span><br><span class="line">            </span><br><span class="line">            Runnable simple = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    simple(processor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(simple).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">(CustomService.Processor&lt;CustomServiceHandler&gt; processor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TServerTransport st = <span class="keyword">new</span> TServerSocket(<span class="number">9090</span>);</span><br><span class="line">            TServer server = <span class="keyword">new</span> TSimpleServer(<span class="keyword">new</span> Args(st).processor(processor));</span><br><span class="line">            System.out.println(<span class="string">"Starting the simple server..."</span>);</span><br><span class="line">            server.serve();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CustomClient.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CustomClient.java</span></span><br><span class="line"><span class="keyword">package</span> com.isudox.thrift.tutorial</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TTransport transport = <span class="keyword">new</span> TSocket(<span class="string">"localhost"</span>, <span class="number">9090</span>);</span><br><span class="line">            transport.open();</span><br><span class="line"></span><br><span class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);  <span class="comment">// 二进制格式</span></span><br><span class="line">            CustomService.Client client = <span class="keyword">new</span> CustomService.Client(protocol);</span><br><span class="line"></span><br><span class="line">            System.out.print(client.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">            System.out.print(client.sayHello(<span class="string">"sudoz"</span>));</span><br><span class="line"></span><br><span class="line">            transport.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TTransportException te) &#123;</span><br><span class="line">            te.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 Server 端 main 函数，会以 simple 的模式启动，然后运行 Client，可以看到输出了 Thrift 定义的接口的函数运行结果。</p><hr><p>参考资料：</p><ul><li><a href="https://thrift.apache.org/tutorial/" target="_blank" rel="noopener">Thrift Tutorial</a></li><li><a href="http://thrift.apache.org/docs/" target="_blank" rel="noopener">Thrift Documentation</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="noopener">Apache Thrift - 可伸缩的跨语言服务开发框架</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解 Thrift IDL 后，就能开始编写自己的 RPC 服务端和客户端了。对 Thrift 的安装过程和命令操作略过不表，主要还是关注如何利用 Thrift 实现 Java 的 RPC 服务端和客户端。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="RPC" scheme="https://isudox.com/tags/RPC/"/>
    
      <category term="Thrift" scheme="https://isudox.com/tags/Thrift/"/>
    
  </entry>
  
  <entry>
    <title>Thrift 学习笔记：IDL</title>
    <link href="https://isudox.com/2017/04/06/thrift-learn-notes-idl/"/>
    <id>https://isudox.com/2017/04/06/thrift-learn-notes-idl/</id>
    <published>2017-04-06T03:08:26.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p>上月底来到了 M 记，氛围和风格都和 J 记有很大不同，很舒服。开发工作还在按照 Mentor 定制的计划学习适应中，部分技术栈之前没接触过，比如 RPC，M 记用的是自己改写的 Thrift，这两天也在看相关的文档，汇总成学习笔记。</p><a id="more"></a><p>Thrift 是由 Facebook 开源、Apache 维护的跨语言 RPC 框架。类似 Google 的 protobuf，Thrift 是典型的 C/S 架构，RPC 客户端和服务端间需要定义 IDL(Interface Description Language) 来实现跨语言通信。本文是对 Thrift IDL 学习的总结。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>参考官方<a href="http://thrift.apache.org/docs/types" target="_blank" rel="noopener">文档</a>，Thrift IDL 的基础类型覆盖了绝大多数编程语言的关键类型，共有以下 7 种：</p><ul><li>bool：布尔值，true 或 false</li><li>byte：8-bit 有符号整数</li><li>i16：16-bit 有符号整数</li><li>i32：32-bit 有符号整数</li><li>i64：64-bit 有符号整数</li><li>double：64-bit 浮点数</li><li>string：UTF-8 编码的字符串</li></ul><p>文档中说明了，IDL 并没有包含无符号整型，这是由于很多编程语言并没有原生的无符号整型数。</p><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><p>Thrift IDL 支持 binary 类型，它是未编码字节序列，是 string 类型的特殊形式。binary 类型提高了和 Java 的互操作性，Thrift 计划在某个时候将其提升为基础类型。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Thrift 结构体定义了公共对象，基本等同于面向对象语言中的类，但没有继承特性。一个结构体有一组强类型的字段，每个字段都有唯一名称标识符。Thrift 接口文件中的结构体类型，编译后会转换成一个类，类的属性就是结构体中的各个类型字段，而类的方法就是对这些类型字段进行处理的相关函数。结构体类型的关键字是 <code>struct</code>，参考下面的 IDL 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    1: i32 id;</span><br><span class="line">    2: string name;</span><br><span class="line">    3: i32 age;</span><br><span class="line">    4: string sex;</span><br><span class="line">    5: i32 grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的，Thrift 编译后生成下面的 Student 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Thrift 容器是强类型的，可以映射成大多数编程语言的容器。Thrift 包含 3 种容器——</p><ul><li>list：元素可重复的有序列表，对应 C++ STL 的 vector、Java 的 ArrayList、脚本语言中的原生数组；</li><li>set：元素不可重复的无序列表，对应 STL 的 set、Java 的 HashSet、Python 的 set；</li><li>map：key 严格唯一的 key-value 字典，对应 STL 的 map、Java 的 HashMap、Python/Ruby 的字典；</li></ul><p>容器元素可能是任意 Thrift 类型。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Thrift 异常和结构体形式上类似，只是关键字是 exception，由指定语言的原生异常类派生，Java 的话，就是 <code>java.lang.Exception</code>。参考下面的 IDL 声明代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exception RequestException &#123;</span><br><span class="line">    1: i32 code;</span><br><span class="line">    2: string message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>Thrift 中的服务定义类似 OOP 语言中的接口（或纯虚函数）。Thrift 编译后，会创建客户端和服务端相应的函数和方法。服务中定义的每个方法都是具有返回类型的。另外，对于 void 方法，可以额外的加上 oneway 关键字，使得方法在执行时不会等待返回结果，直接异步处理。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Thrift 的枚举和 C/C++ 类似，由 <code>enum</code> 关键字声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum UserType &#123;</span><br><span class="line">    VALID,</span><br><span class="line">    INVALID,</span><br><span class="line">    FROZEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 IDL 未对枚举赋值时，枚举型的第一个元素默认赋值为 0，并逐个递增。</p><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>Thrift 通过关键字 <code>typedef</code> 对类型名进行自定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef i32 MyInt</span><br><span class="line">typedef string Str</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>Thrift 支持 <code>include</code> 关键字引入其他 thrift 文件，从而引入外部 thrift 文件中声明的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include &quot;test.thrift&quot;</span><br><span class="line"></span><br><span class="line">service MyService extends test.FacebookService&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Thrift IDL 和 Java 的类型对应关系如下表所示：</p><table><thead><tr><th style="text-align:left">Thrift</th><th style="text-align:left">Java</th></tr></thead><tbody><tr><td style="text-align:left">bool</td><td style="text-align:left">布尔值</td></tr><tr><td style="text-align:left">byte</td><td style="text-align:left">8 位有符号整型</td></tr><tr><td style="text-align:left">i16</td><td style="text-align:left">16 位有符号整型</td></tr><tr><td style="text-align:left">i32</td><td style="text-align:left">32 位有符号整型</td></tr><tr><td style="text-align:left">i64</td><td style="text-align:left">64 位有符号整型</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">64 位浮点数</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">UTF-8 编码的字符串</td></tr><tr><td style="text-align:left">struct</td><td style="text-align:left">公共的对象</td></tr><tr><td style="text-align:left">list</td><td style="text-align:left">元素可重复的有序列表，ArrayList</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">元素不可重复的无序列表，HashSet</td></tr><tr><td style="text-align:left">map</td><td style="text-align:left">key 唯一的字典，HashMap</td></tr><tr><td style="text-align:left">exception</td><td style="text-align:left">Exception</td></tr><tr><td style="text-align:left">service</td><td style="text-align:left">服务的接口</td></tr></tbody></table><hr><p>参考资料：</p><ul><li><a href="http://thrift.apache.org/docs/" target="_blank" rel="noopener">Thrift Documentation</a></li><li><a href="http://thrift.apache.org/tutorial/java" target="_blank" rel="noopener">Thrfit Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上月底来到了 M 记，氛围和风格都和 J 记有很大不同，很舒服。开发工作还在按照 Mentor 定制的计划学习适应中，部分技术栈之前没接触过，比如 RPC，M 记用的是自己改写的 Thrift，这两天也在看相关的文档，汇总成学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="RPC" scheme="https://isudox.com/tags/RPC/"/>
    
      <category term="Thrift" scheme="https://isudox.com/tags/Thrift/"/>
    
  </entry>
  
  <entry>
    <title>[译] 一个行之有效的 Git 分支模型</title>
    <link href="https://isudox.com/2017/02/18/a-successful-git-branching-model-zh/"/>
    <id>https://isudox.com/2017/02/18/a-successful-git-branching-model-zh/</id>
    <published>2017-02-18T06:51:10.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p>原文 <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a> 是 <a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener">gitflow</a> 的作者 nvie 于 2010 年撰写的，最近才看到此文，恨晚。网上和微信公众号推送的 Git 最佳实践多多少少应该从这篇文章中获得过经验值。虽然文中有些表述略显唠叨和陈旧，但不缺干货，搬运过来做个日常开发手册也是好的。</p><a id="more"></a><blockquote><p>上面是废话，下面是译文。</p></blockquote><hr><p>本文里，我会介绍一个在一年前就引入进多个项目（包括工作和个人项目）中的开发模型，实践表明该模型很成功。为此专门写篇文章的想法由来已久，但始终没挤出时间来做，直到现在。我不会细究项目的具体细节，仅仅是项目开发的分支策略和发布管理。</p><p align="center"><img src="https://o70e8d1kb.qnssl.com/git-model@2x.png" width="575"></p><p>该模型专注于使用 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 作为代码版本管理工具。（另外，如果你对 Git 感兴趣，我司的 GitPrime 提供了一些很棒的软件性能实时数据分析功能）</p><h2 id="为什么使用-Git"><a href="#为什么使用-Git" class="headerlink" title="为什么使用 Git"></a>为什么使用 Git</h2><p>关于 Git 相比于中心化的代码管理系统的优劣，可以从网上找到很多相关讨论。作为开发者，我选择 Git。Git 确实改变了开发者们对分支和合并的理解。在之前使用经典的 CVS/Subversion 时，新建分支和合并分支总是有点吓人（小心代码合并时的冲突，它们会咬你）。</p><p>但是用 Git 时，这些日常工作流的主要操作都变得简便易行。举例来说，在 CVS/Subversion 的相关书籍中，分支和合并操作会在靠后的章节中介绍（面向高阶读者），而 Git 的书中，往往是前三章的基础操作里就会做说明。</p><p>由于 Git 的简单性和重用性（repetitive），分支和合并不再是令人生畏的高危操作。版本管理工具应该更多的协助代码的新建分支和合并分支。</p><p>闲言少叙，进入开发模型的正题吧。我要介绍的模型基本上只是团队里每个成员都要遵循的一组开发流程规范。</p><h2 id="去中心化也中心化"><a href="#去中心化也中心化" class="headerlink" title="去中心化也中心化"></a>去中心化也中心化</h2><p>在分支模型下工作良好的代码库，实际上有一个真实的中心代码库。注意这个库被视为一个中心（因为 Git 是分布式的版本管理工具，所以从技术角度上说并不存在中心代码库）。我们将其视为为 origin，因为所有 Git 用户都熟悉这个名称。</p><p><img align="center" src="https://o70e8d1kb.qnssl.com/centr-decentr@2x.png" width="487"></p><p>每个开发者对 origin 进行 pull 和 push 操作。但是除了中心化的 push-pull，每个开发者也可能会建立子团队并 pull 同个子团队里其他成员的代码改动。比如，和两个或更多开发者合作开发一个大的新功能时，避免过早的将开发进行过程中的代码 push 上去。上图中，有 Alice 和 Bob 的小团队，Clair 和 David 的小团队。</p><p>本质上说，这实际上就像是 Alice 定义了一个 Git 远程分支，名叫 bob，并指向 Bob 的代码库，反之亦然。</p><h2 id="主干分支"><a href="#主干分支" class="headerlink" title="主干分支"></a>主干分支</h2><p><img align="right" src="https://o70e8d1kb.qnssl.com/main-branches@2x.png" width="267"><br>我的开发模型实际上从现有的模型中得到很多启发。中心库保有两个伴随代码库整个生命流程的主要分支：</p><ul><li>master</li><li>develop</li></ul><p>Git 用户应该对 origin 上的 <code>master</code> 分支很熟悉。此外，另一个分支命名为 <code>develop</code>。</p><p>我们将 <code>origin/master</code> 分支作为一个主干分支，使得它的 HEAD 指针始终指向可发布的生产状态（production-ready state）。</p><p><code>origin/develop</code> 分支作为另一主干分支，而它的 HEAD 指针始终指向为下一发版而做的最新开发改动。有人把这成为 integration 分支。通常这就是 nightly 版本发布的出处。</p><p>当 <code>develop</code> 分支上的代码开发到 stable 状态并且已经可以发布时，所有的改动都应该 merge 到 <code>master</code> 分支上，然后打上发布版本号的标签。后面会继续讲如何执行这一系列操作。</p><p>因此，每次把改动合并到 <code>master</code> 分支上后，就生成了一个新的可发布的生产状态。我们对合并到 <code>master</code> 分支的行为把控严格，所以理论上，每当 <code>master</code> 分支上有 commit 操作时，我们可以通过 Git hook 脚本实现自动构建并把应用推送到生产服务器上。</p><h2 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a>辅助分支</h2><p>主干分支之外，我们的开发模型使用了很多辅助分支来帮助团队成员间的并行开发，减轻功能跟踪的成本，预备新版的发布，协助快速修复已发布版本的问题。和主干分支不同，这些辅助分支只有有限的生命期，最终会被移除。</p><p>我们可能会用到的辅助分支有：</p><ul><li>Feature 分支</li><li>Release 分支</li><li>Hotfix 分支</li></ul><p>上面的每个辅助分支都有一个特定的目标，且严格限制哪些是起源分支，哪些是合并的目标分支。我们一会儿会详细解释。</p><p>这些辅助分支并不特别，分支的类型是按照我们如何使用它们而划分的，也就是普通的 Git 分支而已。</p><h3 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h3><p><img align="right" src="https://o70e8d1kb.qnssl.com/fb@2x.png" width="133"><br>从 <code>develop</code> 分支派生；<br>必须 merge 回 <code>develop</code> 分支；<br>辅助分支的命名惯例是：除 master，develop，release_* 和 hotfix-* 以外的任意命名。</p><p>Feature 分支，或者叫 topic 分支，是用来为未来的发版而开发新 features 的分支。当开始 feature 的开发时，。Feature 分支的本质它会在 feature 的开发期内存在，但最终会合并回 <code>develop</code> 分支（以明确的将 feature 添加进即将 release 的版本中），或者被直接丢弃掉（在令人失望的情况下）。</p><p>Feature 分支通常只存在于开发者的 repo 中，而不会在中心库 origin repo 中。</p><center><strong>创建 Feature 分支</strong></center><p>要创建一个新的 Feature 分支，从 <code>develop</code> 分支上派生：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b myfeature develop</span><br><span class="line">Switched to a new branch <span class="string">"myfeature"</span></span><br></pre></td></tr></table></figure><center><strong>已完成的 feature 合并回 develop</strong></center><p>已开发完成的 features 应该被合并至 <code>develop</code> 分支上，将 features 添加到即将发 release 的代码版本中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git branch -d myfeature</span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure><p><code>--no-ff</code> 标识使得 merge 操作总是创建一个新的 commit，即使 merge 可以使用 fast-forward。这避免了 feature 分支历史信息的丢失，而且把所有 commit 归并在一起。比较下图的两个案例：</p><p align="center"><img src="https://o70e8d1kb.qnssl.com/merge-without-ff@2x.png" width="478"></p><p>右边的案例中，无法从 Git 历史中找到是哪些 commit 实现了 feature，你必须要手工的去检查所有的 log 信息。撤销一个 feature 对后一案例而言简直是头疼，而如果使用了 –no-ff 标志，则很容易完成。</p><p>是的，它会付出创建更多的 commit 的代价，但所得更多。</p><h3 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h3><p>从 <code>develop</code> 分支派生；<br>必须 merge 回 <code>develop</code> 分支和 <code>master</code> 分支；<br>分支命名惯例：release-*</p><p>Release 分支为新的生产版本做预备。They allow for last-minute dotting of i’s and crossing t’s. 此外，Release 分支也可以用来修复小 bug 和准备发布版本的元数据（版本号，构建日期等）。通过 Release 分支，<code>develop</code> 分支将被清理以便接收下一个大版本的发布。</p><p>从 <code>develop</code> 分支派生新分支的关键时刻是在开发几乎要到达预期的 release 状态时。至少所有针对要构建版本的 feature 必须已经 merge 到 <code>develop</code> 分支上了。而针对未来的 release 的 feature 则需要等到当前的 release 分支派生以后。</p><p>正是在 Release 分支的开始时，而不是之前，即将到来的 release 才被分配版本号。直到那时，<code>develop</code> 分支才反映了 next release 的改动，但直到 release 分支开始前，next release 是 0.3 版还是 1.0 版并不确定。对 release 版本的决定是在 release 分支开始时，并由项目的版本号规则来拟定。</p><center><strong>创建 release 分支</strong></center><p>Release 分支是由 <code>develop</code> 分支派生而来。例如，当前的生产版本是 1.15，且即将有一个大迭代。<code>develop</code> 分支的状态已经为 next release 做好准备，我们也已经决定好即将到来的版本是 1.2。因此我们从当前的 <code>develop</code> 分支上派生并命名该 <code>release</code> 分支为新的版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop</span><br><span class="line">Switched to a new branch <span class="string">"release-1.2"</span></span><br><span class="line">$ ./bump-version.sh 1.2</span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2"</span></span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>创建并切换到新分支后，我们 bump 了版本号。在这里，<code>bump-version.sh</code> 是一个虚拟出来的 shell 脚本，用来修改一些文件，使其能体现新版本。之后，新的版本被 commit 上去。</p><p>该新分支可能会存在一段时间，知道 release 可以确定被发布出来。在此期间，分支上可能会修复一些 bug（而不是在 <code>develop</code> 分支上）。严禁在该分支上添加大的 feature 进来。release 分支最后必须被 merge 回 <code>develop</code> 分支上，然后继续等待下一个大版本的发布。</p><center><strong>完成 release 分支</strong></center><p>当 release 分支的开发状态到了真正可以发布的时候，就需要采取一些行动了。首先， release 分支得 merge 到 <code>master</code> 分支（记住，<code>master</code> 上的每个 commit 都是一个新的 release）。然后，提交到 <code>master</code> 上的 commit 必须被标记上 Tag，以便将来参考该历史版本。最后，release 分支上的改动还需要 merge 回 <code>develop</code> 分支，以便将来的 release 也能包含这些 bug fixes。</p><p>开始的两步操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git tag -a 1.2</span><br></pre></td></tr></table></figure><p>到此，release 已经完成，并且标记了 Tag。（你可能还想使用 <code>-s</code> 或 <code>-u</code> 参数来对 Tag 进行加密）</p><p>为了让 release 分支上的改动能保留下来，继续将改动 merge 回 <code>develop</code> 分支，Git 操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure><p>这些操作可能会导致代码冲突，尝试解决冲突后再提交。<br>现在，我们已经彻底完成工作并且 release 分支已经可以被移除了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-1.2</span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure><h3 id="Hotfix-分支"><a href="#Hotfix-分支" class="headerlink" title="Hotfix 分支"></a>Hotfix 分支</h3><p><img align="right" src="https://o70e8d1kb.qnssl.com/hotfix-branches@2x.png" width="316"><br>从 <code>master</code> 分支派生；<br>必须 merge 回 <code>develop</code> 分支和 <code>master</code> 分支；<br>分支命名惯例：hotfix-*</p><p>Hotfix 分支和 release 分支很类似，都是为发布新的生产版本而准备，虽然是计划外的。其存在的必要性是由于当前生产版本处于需要紧急修复的状态。当生产版本发生严重 bug 时，就必须立即修复，hotfix 分支可以从生产版本的 <code>master</code> 分支上的相应 Tag 派生出来。</p><p>实质上，在 <code>develop</code> 分支上开发的人员可以继续，另一边，其他人员则可以快速的进行生产版本的修复工作。</p><center><strong>创建 release 分支</strong></center><p>Hotfix 分支从 <code>master</code> 派生。比如，当前线上运行的生产版本是 1.2 版，遇到严重 bug，但是 <code>develop</code> 分支上的版本还不到稳定版，就可以派生 hotfix 分支来修复线上发现的 bug：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">Switched to a new branch <span class="string">"hotfix-1.2.1"</span></span><br><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2.1"</span></span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>别忘了在派生新分支后 bump 了版本号。<br>然后，修复 bug 并提交上去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Fixed severe production problem"</span></span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure><center><strong>完成 release 分支</strong></center><p>当 bug 修复完成，修复代码需要合并到 <code>master</code> 分支上，同时还得 merge 到 <code>develop</code> 分支，以保证下一个 release 版本不会出现此 bug。这和 release 分支的结束过程是非常类似的。</p><p>首先，<code>master</code> 分支合并修复代码，然后为新的 release 标记 Tag：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git tag -a 1.2.1</span><br></pre></td></tr></table></figure><p>然后，轮到 <code>develop</code> 分支合并修复代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure><p>有一个例外的原则是，如果当前有一个 release 分支存在，那么 hotfix 分支上的改动需要 merge 到 release 分支，而不是 <code>develop</code> 分支。当 release 分支结束时，merge 到 release 分支上的修复代码最终还是会 merge 到 <code>develop</code> 上。</p><p>最后，移除已经完成历史使命的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix-1.2.1</span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个分支模型虽然没什么令人耳目一新的东西，不过文章一开始给出的那张大图已经呈现了它对我们项目的裨益。它构造了一个优雅的模型，易于理解，并允许团队成员对分支的派生和发布有共同的认识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文 &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A successful Git branching model&lt;/a&gt; 是 &lt;a href=&quot;https://github.com/nvie/gitflow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gitflow&lt;/a&gt; 的作者 nvie 于 2010 年撰写的，最近才看到此文，恨晚。网上和微信公众号推送的 Git 最佳实践多多少少应该从这篇文章中获得过经验值。虽然文中有些表述略显唠叨和陈旧，但不缺干货，搬运过来做个日常开发手册也是好的。&lt;/p&gt;
    
    </summary>
    
      <category term="Translation" scheme="https://isudox.com/categories/Translation/"/>
    
    
      <category term="Git" scheme="https://isudox.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>探索 Spring MVC 重定向和转发</title>
    <link href="https://isudox.com/2017/02/16/spring-mvc-redirect-forward/"/>
    <id>https://isudox.com/2017/02/16/spring-mvc-redirect-forward/</id>
    <published>2017-02-16T03:35:09.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p>最近参与的一个微信公众号相关项目的开发中，业务包含大量的页面跳转逻辑，以及拦截器的数据获取校验。其间也遇到一些困惑，在探究 Spring MVC 中 redirect 和 forward 的源码后，把经验归纳整理出来，遂成此文。</p><a id="more"></a><p>比如客户端的请求进到 Controller 方法中，我们会判断当前用户状态，可能会跳转到用户中心页，也可能会跳转到等待页，又或者错误页。类似的场景很多，都需要用到请求的重定向和转发。Sping MVC 实现重定向或转发的方法有很多，我先大致梳理下，然后再通过源码加深理解。</p><h2 id="常用处理方式"><a href="#常用处理方式" class="headerlink" title="常用处理方式"></a>常用处理方式</h2><p>Controller 视图方法间的跳转，无非就是带参跳转和不带参跳转。常用的方法有通过 String 映射 RequestMapping 实现重定向，或者通过 <code>ModelAndView</code> 对象，又或者是 <code>RedirectView</code> 对象，下面逐一说明。</p><h3 id="String-重定向"><a href="#String-重定向" class="headerlink" title="String 重定向"></a>String 重定向</h3><p>是 return 映射到另一个 Controller 方法的字符串。如果有请求参数，就拼接在 RequestMapping 映射的字符串后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串映射的方式</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/bye"</span>;</span><br><span class="line">    <span class="comment">// return "redirect:/bye?username=sudoz";</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelAndView-重定向"><a href="#ModelAndView-重定向" class="headerlink" title="ModelAndView 重定向"></a>ModelAndView 重定向</h3><p>另一种方法是通过返回 <code>ModelAndView</code> 对象来实现跳转。类似的，如果有请求参数，也可以通过类似 GET 参数拼接的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 ModelAndView 对象</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/bye"</span>);</span><br><span class="line">    <span class="comment">// return new ModelAndView("redirect:/bye?username=sudoz");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RedirectView-重定向"><a href="#RedirectView-重定向" class="headerlink" title="RedirectView 重定向"></a>RedirectView 重定向</h3><p>还有一种方法是通过返回 <code>RedirectView</code> 对象实现跳转，该方法和上面的不同之处在于，<code>RedirectView</code> 对象不需要设置 redirect 前缀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 RedirectView 对象</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">"/bye"</span>);</span><br><span class="line">    <span class="comment">// return new RedirectView("bye?username=sudoz");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带参跳转"><a href="#带参跳转" class="headerlink" title="带参跳转"></a>带参跳转</h2><p>在做方法跳转时，如果要把参数带给下一个方法，像上面代码里通过拼接 URL 参数的方法有时候并不实用。因为参数不一定都是是字符串，而且浏览器对 URL 的长度是有限制的。<code>RedirectAttributes</code> 对象可以用来保存请求重定向时的参数。利用 <code>RedirectAttributes</code> 改写上面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">hello</span><span class="params">(RedirectAttributes attrs)</span> </span>&#123;</span><br><span class="line">    attrs.addAttribute(<span class="string">"message"</span>, <span class="string">"hello"</span>);    </span><br><span class="line">    attrs.addFlashAttribute(<span class="string">"username"</span>, <span class="string">"sudoz"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">hello</span><span class="params">(@ModelAttribute(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">                              @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">    map.put(<span class="string">"username"</span>, username);</span><br><span class="line">    map.put(<span class="string">"message"</span>, message);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，调用 <code>addAttribute()</code> 和 <code>addFlashAttribute()</code> 方法往 <code>RedirectAttributes</code> 对象中插入了两个值，如果看源码，就能知道，<code>RedirectAttributes</code> 接口的实现类 <code>RedirectAttributesModelMap</code> 继承了 <code>ModelMap</code>，本质上就是 <code>HashMap</code> 的子类，因此可以用来存储 Key-Value 对。这两个方法都很常用，使用上也必然存在不同：</p><ul><li><code>addAttribute()</code> 方法会把 Key-Value 作为请求参数添加的 URL 的后面；</li><li><code>addFlashAttribute()</code> 方法会把 Key-Value 暂存在 session 中，在跳转到目标方法后，即完成任务，会从 session 中删掉；</li></ul><p>用 <code>curl</code> 命令来测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://localhost:8080/</span><br><span class="line"></span><br><span class="line">HTTP/1.1 302 </span><br><span class="line">Set-Cookie: JSESSIONID=D1CC5E15FA8EF9474C4CED7D4F660E66;path=/;HttpOnly</span><br><span class="line">Location: http://localhost:8080/hello;jsessionid=D1CC5E15FA8EF9474C4CED7D4F660E66?username=sudoz</span><br><span class="line">Content-Language: en-US</span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Thu, 16 Feb 2017 12:33:46 GMT</span><br></pre></td></tr></table></figure><p>可以看到，通过 <code>addAttribute()</code> 添加的键值对变成了 URL 后面的参数，<code>addFlashAttribute()</code> 方法添加的键值对则没有出现在 URL 上，而是存储在了 session 中。跳转的目标方法通过 <code>@ModelAttribute(&quot;key&quot;)</code> 注解指定接收的参数。</p><h2 id="redirect-和-forward-的区别"><a href="#redirect-和-forward-的区别" class="headerlink" title="redirect 和 forward 的区别"></a>redirect 和 forward 的区别</h2><p>上面列出的 3 种方法，其实都是 Spring MVC 在处理请求时的重定向，即 redirect 跳转。另一种分发请求的方式是转发，即 forward。（我不确定这么翻译是否正确，所以下面就直接用 redirect 和 forward 来表述），二者的区别从 HTTP 的规范中就明确了：</p><ul><li>redirect 的 HTTP 返回码是 302，且跳转的新 URL 会存储在 HTTP Response Headers 的 Location 字段中。客户端在接收到 Response 后，会发起另一次请求，这次请求的 URL 就是重定向的 URL；</li><li>forward 的转发过程只发生在服务端；Servlet 容器会直接把源请求打向目标 URL，而不会经由客户端发起请求；因此客户端接收到的响应是来自转发后的目标方法，但是浏览器呈现的 URL 却并不会改变，且 forward 不能将参数转发出去。</li></ul><h2 id="Spring-Boot-测试"><a href="#Spring-Boot-测试" class="headerlink" title="Spring Boot 测试"></a>Spring Boot 测试</h2><p>为了更清晰的比较各种方法，我把 Spring Boot 的测试代码贴出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"sudoz"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function">String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:hello?username=jim&amp;message=how are you"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"redirectView"</span>)</span><br><span class="line">    <span class="function">RedirectView <span class="title">redirectView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"forward"</span>)</span><br><span class="line">    <span class="function">ModelAndView <span class="title">forward</span><span class="params">(RedirectAttributes attrs)</span> </span>&#123;</span><br><span class="line">        attrs.addFlashAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">        attrs.addAttribute(<span class="string">"message"</span>, <span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"forward:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"redirect"</span>)</span><br><span class="line">    <span class="function">ModelAndView <span class="title">redirect</span><span class="params">(RedirectAttributes attrs)</span> </span>&#123;</span><br><span class="line">        attrs.addFlashAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">        attrs.addAttribute(<span class="string">"message"</span>, <span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">hello</span><span class="params">(Model model, @ModelAttribute(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">                              @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">        map.put(<span class="string">"username"</span>, username);</span><br><span class="line">        map.put(<span class="string">"message"</span>, message);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlBasedViewResolver</span> <span class="keyword">extends</span> <span class="title">AbstractCachingViewResolver</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIRECT_URL_PREFIX = <span class="string">"redirect:"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORWARD_URL_PREFIX = <span class="string">"forward:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">createView</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// If this resolver is not supposed to handle the given view,</span></span><br><span class="line">        <span class="comment">// return null to pass on to the next resolver in the chain.</span></span><br><span class="line">        <span class="keyword">if</span> (!canHandle(viewName, locale)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for special "redirect:" prefix.</span></span><br><span class="line">        <span class="keyword">if</span> (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</span><br><span class="line">            String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());</span><br><span class="line">            RedirectView view = <span class="keyword">new</span> RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible());</span><br><span class="line">            <span class="keyword">return</span> applyLifecycleMethods(viewName, view);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for special "forward:" prefix.</span></span><br><span class="line">        <span class="keyword">if</span> (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</span><br><span class="line">            String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InternalResourceView(forwardUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Else fall back to superclass implementation: calling loadView.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.createView(viewName, locale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料</p><ul><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html" target="_blank" rel="noopener">Spring MVC Documentation</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近参与的一个微信公众号相关项目的开发中，业务包含大量的页面跳转逻辑，以及拦截器的数据获取校验。其间也遇到一些困惑，在探究 Spring MVC 中 redirect 和 forward 的源码后，把经验归纳整理出来，遂成此文。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Java" scheme="https://isudox.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://isudox.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>读 Flask 源码：源码结构</title>
    <link href="https://isudox.com/2017/02/14/explore-flask-source-code-structure/"/>
    <id>https://isudox.com/2017/02/14/explore-flask-source-code-structure/</id>
    <published>2017-02-14T11:47:11.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p>打算对 <a href="https://github.com/pallets/flask" target="_blank" rel="noopener">Flask</a> 的学习做个整理，以 Flask 的 GitHub 代码库的 <code>master</code> 分支为参考。其实早期的 <code>0.3</code> 版还是单文件，整个 <code>flask.py</code> 加上注释也只有 1426 行代码，非常简洁，很适合作为 Python 源码学习的教材。</p><a id="more"></a><p>拿到源码先不着急，就像读书一样，不妨浏览下目录，以便有个全局的了解。Flask 的源码有一个非常好的优点，就是它的注释非常完备，即使不看源码，只看注释，也能有个大概的理解。</p><p>从 Flask 根目录下的 <code>setup.py</code> 可以看到，Flask 依赖的组件主要有 3 个：</p><ul><li><a href="http://werkzeug.pocoo.org/docs/" target="_blank" rel="noopener">Werkzeug</a>：一个 HTTP 和 WSGI 的工具集；</li><li><a href="http://jinja.pocoo.org/docs/" target="_blank" rel="noopener">Jinja2</a>：Python 的前端模板引擎；</li><li><a href="http://pythonhosted.org/itsdangerous/" target="_blank" rel="noopener">itsdangerous</a>：处理并传递可信数据的辅助函数集；</li></ul><p>Flask 的核心代码都在 <code>flask</code> 目录下，其目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">├── ext</span><br><span class="line">│   └── __init__.py     flask 扩展</span><br><span class="line">├── __init__.py         导入模块</span><br><span class="line">├── __main__.py         命令行运行</span><br><span class="line">├── _compat.py          Py2/3 兼容性模块</span><br><span class="line">├── app.py              核心模块</span><br><span class="line">├── blueprints.py       蓝图模块</span><br><span class="line">├── cli.py              命令行支持模块</span><br><span class="line">├── config.py           flask 配置模块</span><br><span class="line">├── ctx.py              flask context 模块</span><br><span class="line">├── debughelpers.py     debug 辅助函数</span><br><span class="line">├── exthook.py          flask 扩展迁移，flaskext.foo 迁移到 flask_foo</span><br><span class="line">├── globals.py          flask 全局变量模块，包括 `g`，`current_app`，`request`</span><br><span class="line">├── helpers.py          辅助函数模块</span><br><span class="line">├── json.py             JSON 支持模块</span><br><span class="line">├── logging.py          日志模块</span><br><span class="line">├── sessions.py         基于 itsdangerous 的 cookie 和 session 模块</span><br><span class="line">├── signals.py          基于 blinker 的信号模块</span><br><span class="line">├── templating.py       桥接 Jinja2 的模板模块</span><br><span class="line">├── testing.py          测试模块</span><br><span class="line">├── views.py            view_func 模块</span><br><span class="line">└── wrappers.py         WSGI request 和 response 的封装模块</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ul><li><a href="http://flask.pocoo.org/docs/0.12/" target="_blank" rel="noopener">Flask Documentation</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打算对 &lt;a href=&quot;https://github.com/pallets/flask&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask&lt;/a&gt; 的学习做个整理，以 Flask 的 GitHub 代码库的 &lt;code&gt;master&lt;/code&gt; 分支为参考。其实早期的 &lt;code&gt;0.3&lt;/code&gt; 版还是单文件，整个 &lt;code&gt;flask.py&lt;/code&gt; 加上注释也只有 1426 行代码，非常简洁，很适合作为 Python 源码学习的教材。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://isudox.com/tags/Python/"/>
    
      <category term="Flask" scheme="https://isudox.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 学习笔记 1：起手式 Hello World</title>
    <link href="https://isudox.com/2017/02/10/spring-boot-note-1/"/>
    <id>https://isudox.com/2017/02/10/spring-boot-note-1/</id>
    <published>2017-02-10T15:59:24.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projects.spring.io/spring-boot/" target="_blank" rel="noopener">Spring Boot</a> 是 Pivotal 团队开发的开源 Java Web 框架，相比同门师兄 Spring，Spring Boot 把开发者从繁重的配置中解放出来，遵循“约定大于配置”(convention over configuration)的设计范式。从零搭建 Spring Boot 项目几乎是傻瓜化的，因为框架把大量配置自动完成了。</p><a id="more"></a><h2 id="Spring-Initializr-创建空项目"><a href="#Spring-Initializr-创建空项目" class="headerlink" title="Spring Initializr 创建空项目"></a>Spring Initializr 创建空项目</h2><p><a href="http://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a> 是 Spring 官方提供的 Spring Boot 项目初始化工具，为开发者实现一个基本的项目骨架。很多 Java IDE 也集成了这个工具，以 Intellij IDEA 为例，新建项目，选择 Spring Initializr，进入如下组件选择面板</p><p><img src="https://o70e8d1kb.qnssl.com/spring-initializr.png" alt="spring boot dependencies"></p><p>其中 Core 包含了像 AOP Cashe 这些核心组件，Web 包含了 SpringMVC Thymeleaf 等 Web 开发组件，还有数据库相关，配置中心相关等一系列组件……因为是 Hello World 程序演示，就不选组件了，直接点下一步，创建空项目。空项目结构如下图。</p><p><img src="https://o70e8d1kb.qnssl.com/spring-boot-structure.png" alt="spring boot project structure"></p><ul><li><code>DemonApplication.java</code>：是应用程序的启动引导类（bootstrap class），也是主要的 Spring 配置类；</li><li><code>DemoApplicationTest.java</code>：集成 JUnit 的测试类；</li><li><code>application.properties</code>：配置应用程序和 Spring Boot 的属性；</li></ul><p>OK，到此为止，第一个 Spring Boot 项目就创建完成了！是的，几乎什么都不需要做，一个能编译能运行的 Spring 项目已经搭建好了，真是幸福到泪奔啊<del>o(&gt;_&lt;)o</del><br>但是空项目什么效果都看不到，所以接下来就往里面填充内容，实现一个简单的 Web 应用。</p><h2 id="集成基础-Web-组件"><a href="#集成基础-Web-组件" class="headerlink" title="集成基础 Web 组件"></a>集成基础 Web 组件</h2><p>上面的项目采用 gradle 作为项目构建工具，所以依赖组件是配置在 <code>build.gradle</code> 文件中。gradle 和 maven 用法相似，选用 gradle 的好处很多，简洁是很重要的一点，参考下面的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向 <code>build.gradle</code> 中添加 SpringMVC </p><hr><p>参考资料：</p><ul><li>《Spring Boot 实战》 Craig Walls</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot&lt;/a&gt; 是 Pivotal 团队开发的开源 Java Web 框架，相比同门师兄 Spring，Spring Boot 把开发者从繁重的配置中解放出来，遵循“约定大于配置”(convention over configuration)的设计范式。从零搭建 Spring Boot 项目几乎是傻瓜化的，因为框架把大量配置自动完成了。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Java" scheme="https://isudox.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://isudox.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>通过反射统一 RPC 调用入口</title>
    <link href="https://isudox.com/2017/02/06/rpc-uni-entry-with-reflection/"/>
    <id>https://isudox.com/2017/02/06/rpc-uni-entry-with-reflection/</id>
    <published>2017-02-06T07:18:55.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目开发中，有这样一个场景，依赖外部很多服务，每个服务从功能上彼此独立，因此各个外部服务的调用也是相对独立的。因此当时为每个调用都写了一个专属的 Porcessor 去处理服务调用的结果。当然好处就是功能区分清晰，不好的地方就是当 Processor 多了后维护起来不太方便。一种思路就是利用反射思想，为 Processor 中的 RPC 调用添加统一入口，通过服务名和方法名对调用进行定位。</p><a id="more"></a><p>代理的思路很简单，但真的非常实用，在实际开发中，合理使用代理，能精简很多固有代码。从代理的统一入口进入，根据传入的远程服务名和方法名，自动定位到需要被远程调用的方法，再传入入参并调用该方法，就能代理过多的 Processor 调用 RPC。</p><p>代理入口的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value = <span class="string">"rpcEntry"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcEntry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Object&gt; serviceMap;  <span class="comment">// 远程服务的 k-v 映射</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Method&gt; actions = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// 存储方法调用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">process</span><span class="params">(String invokeStr, Object[] args)</span> </span>&#123;</span><br><span class="line">        String serviceName = methodKey.split(<span class="string">"\\."</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!actions.containsKey(invokeStr)) &#123;</span><br><span class="line">            Object service = serviceMap.get(serviceName);</span><br><span class="line">            <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Method m : service.getClass().getMethods()) &#123;</span><br><span class="line">                    actions.put(String.format(<span class="string">"%s.%s"</span>, serviceName, m.getName()), m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Method method = actions.get(invokeStr);  <span class="comment">// 定位要调用的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object service = serviceMap.get(serviceName);</span><br><span class="line">            Object res = method.invoke(service, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对调用结果进行自定义处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(String.format(<span class="string">"调用的方法[%s]不存在，请确认。"</span>, methodKey));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的远程服务映射可以在 Spring 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceMap"</span> <span class="attr">class</span>=<span class="string">"java.util.HashMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"example1"</span> <span class="attr">value-ref</span>=<span class="string">"example1ServiceImpl"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"example2"</span> <span class="attr">value-ref</span>=<span class="string">"example2ServiceImpl"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"example3"</span> <span class="attr">value-ref</span>=<span class="string">"example3ServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了统一的调用入口后，如果想调用 example1ServiceImpl.debug() 方法，不需要在专门的 Processor 中进行调用，只需用下面的代码进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RpcEntry rpcEntry;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rpcEntry.process(<span class="string">"example1.debug"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目开发中，有这样一个场景，依赖外部很多服务，每个服务从功能上彼此独立，因此各个外部服务的调用也是相对独立的。因此当时为每个调用都写了一个专属的 Porcessor 去处理服务调用的结果。当然好处就是功能区分清晰，不好的地方就是当 Processor 多了后维护起来不太方便。一种思路就是利用反射思想，为 Processor 中的 RPC 调用添加统一入口，通过服务名和方法名对调用进行定位。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Java" scheme="https://isudox.com/tags/Java/"/>
    
      <category term="RPC" scheme="https://isudox.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Travis CI 持续部署静态站方案</title>
    <link href="https://isudox.com/2017/01/24/deploy-site-with-travis-ci/"/>
    <id>https://isudox.com/2017/01/24/deploy-site-with-travis-ci/</id>
    <published>2017-01-24T14:07:42.000Z</published>
    <updated>2019-03-26T15:34:13.428Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在想 GitHub Page 部署的最佳实践。本站之前的部署方案，是通过在 VPS 上创建 Git 仓库后，再把生成的静态文件同时 Push 到 GitHub Page 和 VPS 的 Git 仓库。其中，VPS 上的 Git 仓库会设置 hook，使得有新的 Commit 被 Push 上来后，自动把 Nginx 下的站点目录进行 Pull 更新。这种方案只是一开始的设置比较麻烦，之后就能一劳永逸，但我觉得还可以再抢救下。</p><a id="more"></a><h2 id="初步方案"><a href="#初步方案" class="headerlink" title="初步方案"></a>初步方案</h2><p>既然核心目标都是一键部署，为什么不利用持续集成，那就用 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 吧，和 GitHub 无缝结合。</p><p>先来梳理下整个部署思路：</p><ol><li>源码文件 Push 到 GitHub Page <code>source</code> 分支;</li><li>Travis-CI 在 GitHub Page <code>source</code> 分支更新后，自动构建生成站点文件；</li><li>Travis-CI 将站点文件推送到 GtiHub Page <code>master</code> 分支，使得 username.github.io 更新；</li><li>VPS 从 GitHub Page <code>master</code> 分支拉取更新；</li></ol><p>也就是说，整个部署过程只需要将写好源码文件 Push 到 GitHub 相应分支，后面的操作全部交给 Travis-CI 处理。</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="Travis-关联-GitHub"><a href="#Travis-关联-GitHub" class="headerlink" title="Travis 关联 GitHub"></a>Travis 关联 GitHub</h3><p>首先要让 Travis 监听 GitHub 的更新，打开 Travis，选择要监听的 GitHub 仓库，选中后记得勾选 “Build only if .travis.yml is present” 和 “Build pushes” 两个选项。</p><p>Travis 要有更改 GitHub 仓库的权限，因此还要到 GitHub 那为 Travis 设置权限 key。打开上面所关联的 GitHub 仓库的 Settings，在 Deploy keys 选项中，为 Travis 添加 SSH key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 ssh key 私钥公钥对，无需 passphrase</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>然后讲 SSH 公钥 <code>id_rsa.pub</code> 粘贴到 Deploy key 中，如下图示——</p><p><img src="https://o70e8d1kb.qnssl.com/deploy-key.png" alt="deploy-key"></p><p>接下来就是将 SSH 私钥赋给 Travis，参考下面的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis encrypt-file ~/.ssh/id_rsa --add</span><br></pre></td></tr></table></figure><p>Travis 命令行工具会根据私钥自动匹配到对应的 GitHub 仓库，控制台会得到类似如下回显——</p><blockquote><p>Detected repository as isudox/isudox.github.io, is this correct? |yes|<br>encrypting /home/sudoz/.ssh/id_rsa for isudox/isudox.github.io<br>storing result as id_rsa.enc<br>storing secure env variables for decryption<br>Make sure to add id_rsa.enc to the git repository.<br>Make sure <strong>not</strong> to add /home/sudoz/.ssh/id_rsa to the git repository.<br>Commit all changes to your .travis.yml.</p></blockquote><p>对 Travis 添加私钥后，就能在 Travis 网站上看到新增的环境变量配置，如下图示——</p><p><img src="https://o70e8d1kb.qnssl.com/travis-env-var.png" alt="travis-environment-variables"></p><p>上面的操作会对私钥再次加密，并在当前路径下生成加密文件 <code>id_rsa.enc</code>，同时在当前路径下的 <code>.travis.yml</code> 配置中添加一条解密命令——</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl aes-256-cbc -K $encrypted_xxx_key -iv $encrypted_xxx_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d</span><br></pre></td></tr></table></figure><p>然后对加密文件解密，存放在 <code>~/.ssh/</code> 下，并配置 <code>~/.ssh/config</code> 指定要使用的私钥文件，这些操作和普通的 SSH 操作是一致的，很易懂。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Set the permission of the key</span></span><br><span class="line">chmod 600 ~/.ssh/id_rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> Start SSH agent</span></span><br><span class="line">eval $(ssh-agent)</span><br><span class="line"><span class="meta">#</span><span class="bash"> Add the private key to the system</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>下面是 <code>~/.ssh/config</code> 的参考——</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>Push 到 GitHub 前还得对 Git 的全局参数进行配置，例如 username 和 email 信息——</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Set Git config</span></span><br><span class="line">git config --global user.name 'sudoz'</span><br><span class="line">git config --global user.email 'me@isudox.com'</span><br></pre></td></tr></table></figure><p>剩下的工作就都是 Hexo 的操作了，安装依赖，构建静态文件，部署静态站点——</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Install Hexo</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h3 id="travis-yml-配置"><a href="#travis-yml-配置" class="headerlink" title="travis.yml 配置"></a>travis.yml 配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'6'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  apt:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"><span class="attr">  ssh_known_hosts:</span> <span class="string">github.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">script</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">.travis/deploy.sh</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">source</span></span><br></pre></td></tr></table></figure><p>Travis deploy script 参考如下——</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Decrypt the private key</span></span><br><span class="line">openssl aes-256-cbc -K $encrypted_xxx_key -iv $encrypted_xxx_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the permission of the key</span></span><br><span class="line">chmod 600 ~/.ssh/id_rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> Start SSH agent</span></span><br><span class="line">eval $(ssh-agent)</span><br><span class="line"><span class="meta">#</span><span class="bash"> Add the private key to the system</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> Copy SSH config</span></span><br><span class="line">cp .travis/ssh_config ~/.ssh/config</span><br><span class="line"><span class="meta">#</span><span class="bash"> Set Git config</span></span><br><span class="line">git config --global user.name 'sudoz'</span><br><span class="line">git config --global user.email 'me@isudox.com'</span><br><span class="line"><span class="meta">#</span><span class="bash"> Clone the repository</span></span><br><span class="line">git clone --branch master git@github.com:isudox/isudox.github.io.git .deploy_git</span><br><span class="line"><span class="meta">#</span><span class="bash"> Deploy to GitHub</span></span><br><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><blockquote><p>需要注意，上面的 deploy.sh 需要有执行权限，<code>chmod +x deploy.sh</code></p></blockquote><p>踩了好几个坑，足足 Push 了 7 次才调试成功</p><p><img src="https://o70e8d1kb.qnssl.com/travis-build-success.png" alt></p><h3 id="VPS-定时更新静态站内容"><a href="#VPS-定时更新静态站内容" class="headerlink" title="VPS 定时更新静态站内容"></a>VPS 定时更新静态站内容</h3><p>Travis CI 完成集成工作后，VPS 就能从 GitHub 上拉取更新了。之前我的方案是在 VPS 上也搭建一个 Git Repo，本地将改动同时 commit 到 GitHub 和 VPS 上的 Repo，触发 VPS Git Repo 的 Hook 事件，将更新拉取并复制静态站全部内容到 Nginx 站点路径下。这次改版不打算沿用之前的方案了，虽然这种 Hook 触发事件很及时高效。我打算使用 Linux 自带的 Crontab 定时任务功能。</p><p>Crontab 的使用很简单，将可执行的脚本或命令通过 <code>crontab -e</code> 写入系统用户的定时任务中即可。我设置的是每小时执行一次 <code>git pull</code> 操作。写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># m h  dom mon dow   command</span><br><span class="line">0 * * * * su -s /bin/sh root -c &apos;cd /usr/share/nginx/html/isudox.github.io &amp;&amp; /usr/bin/git pull -q origin master&apos;</span><br></pre></td></tr></table></figure><p>如果不确定命令行是否生效，可以在控制台里执行下上面的 shell 脚本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在想 GitHub Page 部署的最佳实践。本站之前的部署方案，是通过在 VPS 上创建 Git 仓库后，再把生成的静态文件同时 Push 到 GitHub Page 和 VPS 的 Git 仓库。其中，VPS 上的 Git 仓库会设置 hook，使得有新的 Commit 被 Push 上来后，自动把 Nginx 下的站点目录进行 Pull 更新。这种方案只是一开始的设置比较麻烦，之后就能一劳永逸，但我觉得还可以再抢救下。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="CI" scheme="https://isudox.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器化应用</title>
    <link href="https://isudox.com/2017/01/16/dockerize-applications/"/>
    <id>https://isudox.com/2017/01/16/dockerize-applications/</id>
    <published>2017-01-16T05:30:31.000Z</published>
    <updated>2019-03-26T15:34:13.427Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一篇<a href="http://www.kkblog.me/notes/%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">博文</a>，大受启发，也想着手尝试把自己 VPS 上的应用容器化，一方面尝试下新的开发方式，另一方面也便于应用迁移。</p><a id="more"></a><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Docker 通过 <code>dockerfile</code> 配置来把应用构建成镜像，<code>dockerfile</code> 是一个包含了配置和创建应用的全部命令的文本。Docker 官网上有对 <code>dockerfile</code> 的详细<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">说明文档</a></p><p>看了文档后，对其使用有大致的了解，对不是太复杂的应用的容器化，已经能实践了，下面对 <code>dockerfile</code> 的编写和使用简单总结下。</p><h3 id="编写-dockerfile"><a href="#编写-dockerfile" class="headerlink" title="编写 dockerfile"></a>编写 dockerfile</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><code>FROM</code> 指令会设置要构建的镜像所依赖的基础镜像，比如应用是运行在 Ubuntu 系统上，那么就用 FROM 指定依赖镜像为 Ubuntu，<code>FROM</code> 必须是第一条非注释指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="comment"># tag 可选</span></span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>该指令设置镜像的作者信息。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p><code>RUN</code> 会运行其指定的命令，一个 <code>RUN</code> 运行一条命令，单条命令可以通过 <code>\</code> 反斜杠换行。<code>RUN</code> 支持两种格式：</p><ul><li><code>RUN &lt;cmd&gt;</code>：shell 格式，直接运行一条完整的 shell 命令，默认使用 <code>/bin/sh -c</code> 执行该 shell 命令；</li><li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>： exec 格式，第一个参数是可执行文件，后面跟参数；<br>参考下面的例子：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">'source $HOME/.bashrc; echo $HOME'</span></span></span><br><span class="line"><span class="bash">RUN [<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"echo hello"</span>]</span></span><br></pre></td></tr></table></figure><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p><code>CMD</code> 也是执行命令的指令，和 <code>RUN</code> 的区别在于，<code>RUN</code> 发生在镜像构建过程中，<code>CMD</code> 发生在容器启动时。<code>dockerfile</code> 中只能存在一条有效的 <code>CMD</code> 指令，如果编写了多条，则只有最后一条生效。</p><p><code>CMD</code> 最主要的作用是给容器提供默认的配置，它支持 3 种格式：</p><ul><li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>：exex 格式，推荐；</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>：提供给 ENTRYPOINT 脚本的参数；</li><li><code>CMD command param1 param2</code>：shell 格式；</li></ul><p>参考示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="comment"># shell 格式</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"This is a test."</span> | wc -</span></span><br><span class="line"><span class="bash"><span class="comment"># exec 格式</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"/usr/bin/wc"</span>,<span class="string">"--help"</span>]</span></span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 指令是在容器启动时执行的命令或脚本，一般是对容器进行设置。它支持两种格式：</p><ul><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>：exec 格式，推荐；</li><li><code>ENTRYPOINT command param1 param2</code>：shell 格式；</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -i -t --rm -p 80:80 nginx</span></span><br></pre></td></tr></table></figure><p>例如上面的 nginx 容器启动命令，docker run <image> -d 会将参数 <code>-d</code> 传递给 entry point，如果是在 <code>CMD</code> 中已经被设置的参数，则会被覆盖掉。启动时，如果要覆盖 <code>ENTRYPOINT</code>，可以通过 <code>--entrypoint</code> 标识设置新的 <code>ENTRYPOINT</code>。</image></p><p>只有最后一条 <code>ENTRYPOINT</code> 指令才会生效。</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE</code> 指令设置容器运行时监听的端口号。<code>EXPOSE</code> 并不能直接使容器内端口被主机访问，如果要实现主机访问容器端口，必须通过 <code>-p</code> 标识来指定可访问的容器端口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射一个端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> port1</span><br><span class="line"><span class="comment"># 相应的运行容器使用的命令</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p port1 image</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 映射多个端口</span></span></span><br><span class="line"><span class="bash">EXPOSE port1 port2 port3</span></span><br><span class="line"><span class="bash"><span class="comment"># 相应的运行容器使用的命令</span></span></span><br><span class="line"><span class="bash">docker run -p port1 -p port2 -p port3 image</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 还可以指定需要映射到宿主机器上的某个端口号  </span></span></span><br><span class="line"><span class="bash">docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image</span></span><br></pre></td></tr></table></figure><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p><code>ENV</code> 指令会设置键值对环境变量，它有两种格式：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code>：一次设置单个环境变量；</li><li><code>ENV &lt;key&gt;=&lt;value&gt; ...</code>：一次设置多个环境变量，以空格作为不同环境变量之间的分隔；</li></ul><p>环境变量设置后，无论是在容器镜像构建时，还是在容器启动运行时，都能引用到。另外，在容器运行时，如果需要额外指定环境变量，可以通过 <code>run --env &lt;key&gt;=&lt;value&gt;</code> 设置。</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p><code>ADD</code> 指令把源地址的文件、文件夹复制到目的地址，支持通配符。<code>ADD</code> 有两种格式：</p><ul><li><code>ADD &lt;src&gt;... &lt;dest&gt;</code></li><li><code>ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>：当路径中存在空格时，需要采用这种格式；</li></ul><p><dest> 是绝对路径，或者基于 <code>WORKDIR</code> 的相对路径，例如：</dest></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="built_in">test</span> relativeDir/          <span class="comment"># adds "test" to `WORKDIR`/relativeDir/</span></span></span><br><span class="line"><span class="bash">ADD <span class="built_in">test</span> /absoluteDir/         <span class="comment"># adds "test" to /absoluteDir/</span></span></span><br></pre></td></tr></table></figure><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p><code>WORKDIR</code> 设置工作目录，类似 shell 的 <code>cd</code>，使 <code>RUN</code> <code>CMD</code> <code>ENCRYPT</code> <code>COPY</code> <code>ADD</code> 指令在该工作目录下执行。在 <code>dockerfile</code> 中，<code>WORKDIR</code> 可以多次指定，如果设置的是一个相对路径，则是相对于前一个 <code>WORKDIR</code> 设置的路径，比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="bash">WORKDIR b</span></span><br><span class="line"><span class="bash">WORKDIR c</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>得到的结果应该是 <code>/a/b/c</code>。</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p><code>COPY</code> 和 <code>ADD</code> 功能上基本相同，不同之处在于，<code>ADD</code> 支持从远程拉取文件复制到 <dest>，支持自动解压 <code>tar</code> 包并删除。</dest></p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p><code>VOLUME</code> 指令创建一个挂载点，使得容器内的该挂载点具有持久数据的功能，换句话说，就是容器和主机之间的共享目录，当关闭容器后，共享目录仍会保留。参考示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /myvol</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /myvol/greeting</span></span><br><span class="line"><span class="bash">VOLUME /myvol</span></span><br><span class="line"><span class="bash"><span class="comment"># 多个挂载点</span></span></span><br><span class="line"><span class="bash"><span class="comment"># VOLUME ["&lt;mountpoint1&gt;, &lt;mountpoint2&gt;"]</span></span></span><br></pre></td></tr></table></figure><p><code>myvol</code> 成为容器在主机里的挂载点。容器的挂载点还可以提供给其他容器使用，只需通过 <code>-volumes-from</code> 标识指定要使用的容器挂载点即可。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -t -i -rm -volumes-from container1 image2 bash</span></span><br></pre></td></tr></table></figure><p>其中，container1 为第一个容器的 ID， image2 为第二个容器运行镜像的名称。</p><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p><code>USER</code> 指令设置容器运行时和执行 <code>RUN</code> <code>CMD</code> <code>ENTRYPOINT</code> 的用户或 UID，默认为 root 用户。</p><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p><code>ARG</code> 指令规定了用户在通过 <code>docker build --build-arg &lt;varname&gt;=&lt;value&gt;</code> 构建镜像时允许传递的变量 varname。如果用户传递了 dockerfile 中未定义的变量，构建会报 “One or more build-args were not consumed, failing build.” 的错误信息。</p><p><code>ARG</code> 也可以设置默认变量值，当设置了默认值后，用户如果在构建时没有传相应变量，则使用默认值，构建正常进行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p>还有一个注意点，当 <code>ARG</code> 和 <code>ENV</code> 同时设置了一个变量时，<code>ENV</code> 的设置会覆盖 <code>ARG</code>。</p><h3 id="dockerfile-完整示例"><a href="#dockerfile-完整示例" class="headerlink" title="dockerfile 完整示例"></a>dockerfile 完整示例</h3><p>官网给了几个完整的 <code>dockerfile</code> 示例，例如 Firefox over VNC：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Firefox over VNC</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install vnc, xvfb in order to create a 'fake' display and firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span></span><br><span class="line"><span class="bash">RUN mkdir ~/.vnc</span></span><br><span class="line"><span class="bash"><span class="comment"># Setup a password</span></span></span><br><span class="line"><span class="bash">RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</span></span><br><span class="line"><span class="bash"><span class="comment"># Autostart firefox (might not be the best way, but it does the trick)</span></span></span><br><span class="line"><span class="bash">RUN bash -c <span class="string">'echo "firefox" &gt;&gt; /.bashrc'</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 5900</span></span><br><span class="line"><span class="bash">CMD    [<span class="string">"x11vnc"</span>, <span class="string">"-forever"</span>, <span class="string">"-usepw"</span>, <span class="string">"-create"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="容器化应用实践"><a href="#容器化应用实践" class="headerlink" title="容器化应用实践"></a>容器化应用实践</h2><h3 id="shadowsocks-libev"><a href="#shadowsocks-libev" class="headerlink" title="shadowsocks-libev"></a>shadowsocks-libev</h3><p><a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">shadowsocks-libev</a> 的容器化相对比较简单，对上面的指令初步了解后，再参考别人已有的镜像，实践编写 dockerfile 不算麻烦。</p><p>我的 VPS 是 Debian 系统，<code>FROM</code> 可以设为 debian，不过还是选了非常了流行的小镜像 <a href="https://alpinelinux.org/" target="_blank" rel="noopener">alpine</a>。然后根据 shadowsocks-libev README 编写安装的命令。</p><p>shadowsocks-libev 的源码编译安装过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Debian / Ubuntu</span></span><br><span class="line">sudo apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev asciidoc xmlto zlib1g-dev</span><br><span class="line">./autogen.sh &amp;&amp; ./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>如果采用 Alpine 作为基础镜像的话，个别命令要改动，<code>apt-get install</code> 要替换成 <code>apk add</code>。用 <code>RUN</code> 指令完成源码的编译安装。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DEP asciidoc autoconf build-base curl libtool linux-headers openssl-dev pcre-dev tar xmlto</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache --virtual .build-deps <span class="variable">$DEP</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    curl -sSL <span class="variable">$URL</span> | tar xz &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> <span class="variable">$DIR</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">        ./configure --<span class="built_in">disable</span>-documentation &amp;&amp; \</span></span><br><span class="line"><span class="bash">        make install &amp;&amp; \</span></span><br><span class="line"><span class="bash">        <span class="built_in">cd</span> .. &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk del .build-deps &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -rf <span class="variable">$DIR</span></span></span><br></pre></td></tr></table></figure><p>参考 shadowsocks 的启动参数，编写 <code>CMD</code> 或 <code>ENTRYPOINT</code> 指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> ss-server -s <span class="variable">$ADDR</span> \</span></span><br><span class="line"><span class="bash">              -p <span class="variable">$PORT</span> \</span></span><br><span class="line"><span class="bash">              -k <span class="variable">$&#123;PASSWORD:-$(hostname)&#125;</span> \</span></span><br><span class="line"><span class="bash">              -m <span class="variable">$METHOD</span> \</span></span><br><span class="line"><span class="bash">              -t <span class="variable">$TIMEOUT</span> \</span></span><br><span class="line"><span class="bash">              --fast-open \</span></span><br><span class="line"><span class="bash">              -d <span class="variable">$DNS</span> \</span></span><br><span class="line"><span class="bash">              -u</span></span><br></pre></td></tr></table></figure><p>本地构建成功后，就可以推送镜像到 Docker Hub 分享给他人，或者把 Dockerfile 上传到 GitHub，通过 Docker Hub 关联 GitHub 实现自动构建。完整的 Dockerfile 已上传到 GitHub 仓库，并结合 Docker Hub 实现自动构建镜像：</p><ul><li>GitHub <a href="https://github.com/isudox/dockerfile/tree/master/shadowsocks-libev" target="_blank" rel="noopener">仓库地址</a></li><li>Docker Hub <a href="https://hub.docker.com/r/sudoz/shadowsocks-libev/" target="_blank" rel="noopener">镜像地址</a></li></ul><p>Docker Hub 上有镜像后，以后再安装 shadowsocks 只需要一条命令就能完成安装和配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e METHOD=aes-256-cfb -e PASSWORD=123456 -p 8388:8388 --restart always sudoz/shadowsocks-libev</span><br></pre></td></tr></table></figure><p>一劳永逸！</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>如果每次启动 Docker 镜像都要手敲一大段命令来给容器配置参数的话，还是不够简洁优雅，docker-compose 就解决了这个问题，直接把配置写成文本，由 docker-compose 来读取配置文件 <code>docker-compose.yml</code> 并启动容器，真正做到一次编写，到处运行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shadowsocks:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">sudoz/shadowsocks-libev</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"8388:8388"</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">METHOD=aes-256-cfb</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">PASSWORD=123456</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>配置很明白，对应了 <code>docker run</code> 启动容器时的参数配置，现在只需要一行简单的命令来启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ul><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></li><li><a href="http://zone.gaospot.com/2016/05/11/Docker%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">Docker 镜像创建</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一篇&lt;a href=&quot;http://www.kkblog.me/notes/%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博文&lt;/a&gt;，大受启发，也想着手尝试把自己 VPS 上的应用容器化，一方面尝试下新的开发方式，另一方面也便于应用迁移。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Docker" scheme="https://isudox.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>展望 2017</title>
    <link href="https://isudox.com/2017/01/01/todo-list-2017/"/>
    <id>https://isudox.com/2017/01/01/todo-list-2017/</id>
    <published>2016-12-31T16:39:29.000Z</published>
    <updated>2019-03-26T15:34:13.427Z</updated>
    
    <content type="html"><![CDATA[<p>看完李安的《推手》，迎来了 2017 年的第一天。这算是新的一年里的开篇吧，就不写代码了，看社区里很多同行在做过 2016 年的总结，或是新一年的期望。对过去一年，我似乎很难整理出一条清晰的逻辑去完整的复盘和总结，总体来讲，自己并不是很满意，当然也有令我激动的地方，比如遇到了 Kiki 啊……自认为在毕业后的一年里没有取得自己想要的进步，没有达到我想达到的层次，新的一年里还得加油啊。既然不做总结了，展望还是要有的，万一做到了呢？</p><a id="more"></a><blockquote><p>博客的 Markdown 解析器好像不支持 <code>checkbox</code> 语法，尴尬</p></blockquote><ul><li>锻炼身体，体重达到 65 kg 以上，用肌肉武装自己；</li><li>学习英语，雅思争取拿到满意的成绩；</li><li>提升阅读量，重拾中学时的阅读热情。目标每个月都能啃掉一本书；</li><li>向 Kiki 学吉他，光看 Live 有什么劲啊；</li><li>养一条狗，陪它长大；</li><li>好好写博客，向大牛看齐，写出有深度有干货的技术博客，好好混 GitHub，写出自己满意的开源作品；</li><li>为爱自己的人，为自己爱的人，赚钱！赚更多钱！！赚好多钱！！！</li></ul><p>嗯，就是这样。其实上面有些是 2016 年的计划，当然这就意味着我没做到，只能延期一年，希望明年这时候会是另外一个状态。</p><p>最后，既然是程序员，自然要用程序员的方式辞旧迎新——</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">2016</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">2017</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完李安的《推手》，迎来了 2017 年的第一天。这算是新的一年里的开篇吧，就不写代码了，看社区里很多同行在做过 2016 年的总结，或是新一年的期望。对过去一年，我似乎很难整理出一条清晰的逻辑去完整的复盘和总结，总体来讲，自己并不是很满意，当然也有令我激动的地方，比如遇到了 Kiki 啊……自认为在毕业后的一年里没有取得自己想要的进步，没有达到我想达到的层次，新的一年里还得加油啊。既然不做总结了，展望还是要有的，万一做到了呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://isudox.com/categories/Life/"/>
    
    
      <category term="Todo" scheme="https://isudox.com/tags/Todo/"/>
    
  </entry>
  
  <entry>
    <title>2016 前端补习 Yarn 篇</title>
    <link href="https://isudox.com/2016/12/27/yarn-front-end-development-trends-in-2016/"/>
    <id>https://isudox.com/2016/12/27/yarn-front-end-development-trends-in-2016/</id>
    <published>2016-12-27T14:39:09.000Z</published>
    <updated>2019-03-26T15:34:13.427Z</updated>
    
    <content type="html"><![CDATA[<p>目前使用最广泛的 JavaScript 的包管理工具应该是 npm，可以说是非常时髦的工具。但是在前端圈子，三岁就得叫爷爷，拳怕少壮，不久前 Facebook 和 Google 等联手推出了新的包管理工具 Yarn，一阵横扫之势，GitHub 上狂收 2w+ stars，令人侧目……在上一篇讲 webpack 学习的博客中也尝试使用了 Yarn，本篇就专门写写 Yarn。</p><a id="more"></a><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>如果使用过 npm 的话，能发现二者在使用上非常接近，从 npm 迁移到 Yarn 近乎零成本。</p><p>初始化新项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># same as npm init</span></span><br><span class="line">yarn init</span><br></pre></td></tr></table></figure><p>执行该命令时，会询问项目名称，入口文件，作者等信息，确认后自动创建包管理文件 <code>package.json</code>，以后每次对包的增删更新都会同步到 <code>package.json</code> 中。</p><p>安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># same as npm install [package]</span></span><br><span class="line">yarn add [package]</span><br><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br></pre></td></tr></table></figure><p>另外，该命令可以通过标识参数来指定依赖类型：</p><ul><li><code>yarn add --dev</code> 会把依赖包添加进 <code>devDependencies</code> 字段；</li><li><code>yarn add --peer</code> 会把依赖包添加进 <code>peerDependencies</code> 字段；</li><li><code>yarn add --optional</code> 会把依赖包添加进 <code>optionalDependencies</code> 字段；</li></ul><p>更新依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># same as npm upgrade [package]</span></span><br><span class="line">yarn upgrade [package]</span><br><span class="line">yarn upgrade [package]@[version]</span><br><span class="line">yarn upgrade [package]@[tag]</span><br></pre></td></tr></table></figure><p>卸载依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># same as npm uninstall [package]</span></span><br><span class="line">yarn remove [package]</span><br></pre></td></tr></table></figure><p>根据 <code>package.json</code> 安装所有依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># same as npm install</span></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>该命令也支持通过标识参数来实现额外的功能：</p><ul><li><code>yarn install --flat</code> 每个包都只允许安装唯一的版本，第一次运行时会提示用户确认版本；</li><li><code>yarn install --force</code> 强制联网下载所有包，即使之前下载过；</li><li><code>yarn install --production</code> 使用该标识符或者环境变量 <code>NODE_ENV</code> 为 <code>production</code> 时，Yarn 会忽略 <code>devDependencies</code> 中的依赖包；</li></ul><p>除了 <code>package.json</code> 外，Yarn 还维护了 <code>yarn.lock</code> 来精确匹配所有依赖包的版本号，来弥补 <code>package.json</code> 管理依赖包版本时的不精确问题。因此，如果使用 Yarn，需要把 <code>yarn.lock</code> 添加进版本管理中。</p><p>Yarn 还有其他一些比较常用的命令：</p><ul><li><code>yarn clean</code> 命令会清理掉不需要的依赖包，释放 <code>node_modules</code> 的空间。在执行该命令后，Yarn 会在项目根目录下创建 <code>.yarnclean</code> 文件，它也应该添加到版本管理中；</li><li><code>yarn config set &lt;key&gt; &lt;value&gt; [-g|--global]</code> 命令会设置默认的 Yarn 信息，相应的，读取的命令是 <code>yarn config get &lt;key&gt;</code>。可以设置的 <code>key</code> 可以由 <code>yarn config list</code> 命令查看到；</li><li><code>yarn global</code> 是一个前缀命令，可以加在 <code>add</code>、<code>remove</code> 等命令上，使得作用在全局上，类似 npm 的 <code>--global</code> 参数；</li><li><code>yarn info &lt;package&gt;</code> 命令用来查看依赖包的详细信息；</li><li><code>yarn login</code> 和 <code>yarn logout</code> 命令分别用来登录和登出 npm 的账户；</li><li><code>yarn run [script] [-- &lt;args&gt;]</code> 命令用来执行 <code>package.json</code> 配置的 <code>scripts</code> 脚本命令，和 <code>npm run [script]</code> 一样；</li><li><code>yarn why [package]</code> 命令检查安装该依赖包的原因，并列出依赖该包的其他包；</li></ul><h2 id="npm-命令比较"><a href="#npm-命令比较" class="headerlink" title="npm 命令比较"></a>npm 命令比较</h2><table><thead><tr><th style="text-align:center">npm</th><th style="text-align:center">Yarn</th></tr></thead><tbody><tr><td style="text-align:center">npm install</td><td style="text-align:center">yarn install</td></tr><tr><td style="text-align:center">(N/A)</td><td style="text-align:center">yarn install –flat</td></tr><tr><td style="text-align:center">(N/A)</td><td style="text-align:center">yarn install –har</td></tr><tr><td style="text-align:center">(N/A)</td><td style="text-align:center">yarn install –no-lockfile</td></tr><tr><td style="text-align:center">(N/A)</td><td style="text-align:center">yarn install –pure-lockfile</td></tr><tr><td style="text-align:center">npm install [package]</td><td style="text-align:center">(N/A)</td></tr><tr><td style="text-align:center">npm install –save [package]</td><td style="text-align:center">yarn add [package]</td></tr><tr><td style="text-align:center">npm install –save-dev [package]</td><td style="text-align:center">yarn add [package] [–dev/-D]</td></tr><tr><td style="text-align:center">(N/A)</td><td style="text-align:center">yarn add [package] [–peer/-P]</td></tr><tr><td style="text-align:center">npm install –save-optional [package]</td><td style="text-align:center">yarn add [package] [–optional/-O]</td></tr><tr><td style="text-align:center">npm install –save-exact [package]</td><td style="text-align:center">yarn add [package] [–exact/-E]</td></tr><tr><td style="text-align:center">(N/A)</td><td style="text-align:center">yarn add [package] [–tilde/-T]</td></tr><tr><td style="text-align:center">npm install –global [package]</td><td style="text-align:center">yarn global add [package]</td></tr><tr><td style="text-align:center">npm rebuild</td><td style="text-align:center">yarn install –force</td></tr><tr><td style="text-align:center">npm uninstall [package]</td><td style="text-align:center">(N/A)</td></tr><tr><td style="text-align:center">npm uninstall –save [package]</td><td style="text-align:center">yarn remove [package]</td></tr><tr><td style="text-align:center">npm uninstall –save-dev [package]</td><td style="text-align:center">yarn remove [package]</td></tr><tr><td style="text-align:center">npm uninstall –save-optional [package]</td><td style="text-align:center">yarn remove [package]</td></tr><tr><td style="text-align:center">npm cache clean</td><td style="text-align:center">yarn cache clean</td></tr><tr><td style="text-align:center">rm -rf node_modules &amp;&amp; npm install</td><td style="text-align:center">yarn upgrade</td></tr></tbody></table><h2 id="package-json-依赖配置"><a href="#package-json-依赖配置" class="headerlink" title="package.json 依赖配置"></a>package.json 依赖配置</h2><h3 id="功能区分管理"><a href="#功能区分管理" class="headerlink" title="功能区分管理"></a>功能区分管理</h3><p>有的依赖包是为了编译构建工程，而有的包视为了运行，因此不同功能的包在 <code>package.json</code> 中被分离到不同的依赖集合中：<code>dependencies</code>、<code>devDependencies</code>、<code>optionalDependencies</code> 和 <code>peerDependencies</code>。</p><p>参考 Yarn 文档里的示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-project"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"package-a"</span>: <span class="string">"^1.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"package-b"</span>: <span class="string">"^1.2.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"peerDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"package-c"</span>: <span class="string">"^2.5.4"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"optionalDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"package-d"</span>: <span class="string">"^3.1.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的最多的应该是 <code>dependencies</code> 和 <code>devDependencies</code>，下面按照官方文档具体说明：</p><ul><li><code>dependencies</code>：记录运行程序时所需的依赖包；</li><li><code>devDependencies</code>：这是开发的依赖包，是开发构建时所需的依赖包，但在运行时不需要；</li><li><code>peerDependencies</code>：只有当开发者需要发布自己的包时，才需要配置；</li><li><code>optionalDependencies</code>：顾名思义就是可选的依赖包，即使安装失败，也不会影响；</li><li><code>bundledDependencies</code>：是项目内部的包，而不是从 npm 上安装；</li></ul><h3 id="版本号管理"><a href="#版本号管理" class="headerlink" title="版本号管理"></a>版本号管理</h3><p><code>package.json</code> 也对依赖包的版本做了管理，版本号遵循 <code>major.minor.patch</code> 的规则，如果是 beta 版，则会在版本号后追加 <code>-beta.x</code>。除了明确指定版本号，还可以通过操作符实现指定版本号范围。</p><p>最简单易懂的就是 <code>=</code>、<code>&gt;</code>、<code>&lt;=</code> 等符号，这个不多讲，还有两个特殊的符号 <code>~</code> 和 <code>^</code>：</p><ul><li><code>~</code> 符：当版本号带有 <code>minor</code> 版本时，<code>~</code> 表示允许 <code>patch</code> 版本在 <code>minor</code> 保持不变时，递增变化。比如 <code>~3.1.4</code> 等同 <code>&gt;=3.1.4 &lt;3.2.0</code>；<code>~3.1</code> 等同于 <code>3.1.x</code>。当 <code>~</code> 后的版本号只有 <code>major</code> 时，只允许在 <code>major</code> 不变时，<code>minor</code> 的变化，比如 <code>~3</code> 等同于 <code>3.x</code>。</li><li><code>^</code> 符：允许版本号在不改变第一个非零版本位的范围变动，比如 <code>^3.1.4</code> 表示 <code>&gt;=3.1.4 &lt;4.0.0</code>，<code>^0.4.2</code> 表示 <code>&gt;=0.4.2 &lt;0.5.0</code>， <code>^0.0.2</code> 表示 <code>&gt;=0.0.2 &lt;0.0.3</code>。Yarn 在安装依赖包时，默认使用 <code>^</code> 来设置版本号。</li></ul><p>还有逻辑符号，用空格表示 <code>and</code> 关系，<code>||</code> 表示 <code>or</code> 关系，比如 <code>&gt;=2.0.0 &lt;3.1.4</code> 的意思是版本号大于等于 <code>2.0.0</code> 且小于 <code>3.1.4</code>。连字符 <code>-</code> 很有用，直接表示起止范围，上面这个版本范围用 <code>-</code> 符表示的话就是 <code>2.0.0 - 3.1.4</code>。</p><p>Yarn 的内容不多，使用也很简单，花半小时操练下命令就都了解了。</p><hr><p>参考资料：</p><ul><li>Yarn - <a href="https://yarnpkg.com/en/docs" target="_blank" rel="noopener">Docs</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前使用最广泛的 JavaScript 的包管理工具应该是 npm，可以说是非常时髦的工具。但是在前端圈子，三岁就得叫爷爷，拳怕少壮，不久前 Facebook 和 Google 等联手推出了新的包管理工具 Yarn，一阵横扫之势，GitHub 上狂收 2w+ stars，令人侧目……在上一篇讲 webpack 学习的博客中也尝试使用了 Yarn，本篇就专门写写 Yarn。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Frontend" scheme="https://isudox.com/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>2016 前端补习 Webpack 篇</title>
    <link href="https://isudox.com/2016/12/26/webpack-front-end-development-trends-in-2016/"/>
    <id>https://isudox.com/2016/12/26/webpack-front-end-development-trends-in-2016/</id>
    <published>2016-12-26T02:40:41.000Z</published>
    <updated>2019-03-26T15:34:13.427Z</updated>
    
    <content type="html"><![CDATA[<p>对于前端开发者而言，2016 又是一个风不平浪不静的一年。今年新冒出的框架工具，如果不是专职前端或全栈，估计现在和我是差不多的状态，一脸懵逼外加黑人问号脸。为了以后和前端协作时不被鄙视，努力在 2016 年结束前，赶紧先上车，这就是我一个后端开发做前端补习的动机，本文是 Webpack 篇，后续还会更新 Yarn、React、Redux 等。</p><a id="more"></a><blockquote><p>因为我对前端的认知停留在三脚猫的水平，因此本文不会执著于对不同框架/工具的优劣比较，谨作为个人浅尝辄止的学习记录。</p></blockquote><h2 id="Webpack-基础命令"><a href="#Webpack-基础命令" class="headerlink" title="Webpack 基础命令"></a>Webpack 基础命令</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p><img src="https://webpack.github.io/assets/what-is-webpack.png" alt="What is webpack"></p><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> 是一个前端的模块（Module Bundler）打包工具，如上图所示，它可以对各种类型的静态文件做统一的加载和处理。在展开对它的学习之前，先把准备工作做好，Webpack 的安装很简单，全局或本地安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># globally install</span></span><br><span class="line">yarn global add webpack@2.1.0-beta.20</span><br><span class="line"><span class="comment"># locally install</span></span><br><span class="line">yarn add webpack@2.1.0-beta.20 -D</span><br></pre></td></tr></table></figure><p>安装完后，就可以在控制台使用 <code>webpack</code> 命令了。在目录下执行 <code>webpack</code>，首先需要配置 <code>webpack.config.js</code> 文件，由该配置文件来控制 <code>webpack</code> 的操作。参考阮一峰老师 GitHub 上的示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后执行 <code>webpack</code> 命令就可以按照配置文件的设置，把目录下的 <code>main.js</code> 打包成 <code>bundle.js</code>。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>Webpack 有 4 个核心概念必须要了解：<a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener">Entry</a>、<a href="https://webpack.js.org/concepts/output/" target="_blank" rel="noopener">Output</a>、<a href="https://webpack.js.org/concepts/loaders/" target="_blank" rel="noopener">Loaders</a> 和 <a href="https://webpack.js.org/concepts/plugins/" target="_blank" rel="noopener">Plugins</a>。</p><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>webpack 为 web 应用的依赖关系创建了图表，而 Entry 则是告诉 webpack 这张图表的入口位置并循着依赖关系去打包，webpack 通过对 webpack configuration object 设置 <code>entry</code> 属性来定义 Entry，参考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># webpack.config.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要指定多个 Entry，则需要将 <code>entry</code> 属性从 <code>string</code> 改为 <code>Array&lt;string&gt;</code>，比如 [‘./main.js’, ‘./index.js’]。也可以使用 Object 语法，把 <code>entry</code> 属性设置为一个 key-value 对象，这是更具扩展性的定义 <code>entry</code> 的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>既然由 Bundle 的入口 Entry，相应的必然也会有 Bundle 的出口，这就是 Output。我们需要告知 webpack 对打包后的静态资源如何处置，存放在哪，文件名是什么。webpack 的 <code>output</code> 属性描述了该如何处理打包后的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># webpack.config.js</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>output.filename</code>，如果 <code>entry</code> 属性配置了多个文件，则需要使用命名替换的方式确保 output filename 不重名。其中，占位符 <code>[name]</code> 采用 chunk 的名称作为替换，<code>[hash]</code> 是采用编译后文件的 hash 值替换，而 <code>[chunkhash]</code> 则是根据 chunk 的 hash 值来替换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/build'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>output.path</code> 属性，必须设为绝对路径，占位符 <code>[hash]</code> 会被编译后文件的 hash 值替换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">"/home/proj/public/assets"</span>,</span><br><span class="line">    publicPath: <span class="string">"/assets/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h4><p>webpack 可以对项目里所有静态资源（包括 <code>.css</code>、<code>.html</code>、<code>scss</code>、<code>jpg</code> 等）所谓模块进行处理，但是 webpack 只能理解 JavaScript，如果要处理其他类型的静态文件，就需要 webpack 的 Loaders，把这些静态文件转换成模块的处理器。在 <code>webpack.config.js</code> 的 Loaders 属性配置中，有两个目标需要确认：</p><ol><li>标识什么文件可以被转换成模块（由 <code>test</code> 属性指定）；</li><li>指定转换这些文件的处理器 loader（由 <code>use</code> 属性指定）;</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),  <span class="comment">// bundle 文件的绝对路径</span></span><br><span class="line">    publicPath: <span class="string">"/dist/"</span>,  <span class="comment">// 网站运行时的访问路径</span></span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span>  <span class="comment">// bundle 的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.(js|jsx)$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的配置，通过 <code>rule</code> 属性对单个模块的处理进行设置，因此 webpack 会对项目依赖关系中被 <code>require</code> 或 <code>import</code> 的 <code>.js</code> 和 <code>.jsx</code> 文件，在它们被添加进 bundle 之前，用 <code>babel-loader</code> 处理器进行转换处理（该处理器会把 JSX 和 ES6 的文件转换成 JS 文件）。另外，loaders 的名称都是 <code>xxx-loader</code> 格式，<code>use</code> 属性也可以简写为 <code>xxx</code>。</p><h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>Loaders 只能在 bundle 之前对静态资源作预处理，而 Plugins 则可以对编译后文件和 chunk 文件进行处理，比如 <code>UglifyJsPlugin</code> 可以对 bundle 后的 JavaScript 代码进行压缩处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> uglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结合-React"><a href="#结合-React" class="headerlink" title="结合 React"></a>结合 React</h2><p>在了解 webpack 的基础操作后，可以在 React 项目中实际运用 webpack 进行打包。为了便于描述，就采用最简单的 Hello World 例子。React 项目结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- hello-world</span><br><span class="line">    - dist/</span><br><span class="line">    - src/</span><br><span class="line">        - js/</span><br><span class="line">            Welcome.js</span><br><span class="line">            entry.js</span><br><span class="line">    index.html</span><br><span class="line">    webpack.config.js</span><br></pre></td></tr></table></figure><p>其中，<code>Welcome.js</code> 定义了一个 React Component，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Welcome.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry.js</code> 是依赖关系的入口文件，引入依赖的模块，并输出页面元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Welcome <span class="keyword">from</span> <span class="string">'./Welcome'</span>;</span><br><span class="line"></span><br><span class="line">React.render(<span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"sudoz"</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>而 <code>index.html</code> 的页面源码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This HTML file is a template. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code> 需要对 React 的 JSX 文件进行 babel 转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    path.resolve(root_path, <span class="string">'./src/js/entry'</span>)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(root_path, <span class="string">'dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js[x]$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><p>当修改、新增或移除模块时，热替换（Hot Module Replacement, HMR）可以使程序无需重新载入页面就能实现更新。</p><p>要使用 HMR，需要安装一下依赖，另外在安装 React 依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D babel@6.5.2 babel-core@6.13.2 babel-loader@6.2.4 babel-preset-es2015@6.13.2 babel-preset-react@6.11.1 babel-preset-stage-2@6.13.0 css-loader@0.23.1 postcss-loader@0.9.1 react-hot-loader@3.0.0-beta.6 style-loader@0.13.1 webpack@2.1.0-beta.20 webpack-dev-server@2.1.0-beta.0</span><br><span class="line"></span><br><span class="line">yarn add react@15.3.0 react-dom@15.3.0</span><br></pre></td></tr></table></figure><p>配置 <code>.babelrc</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"es2015"</span>, &#123;<span class="string">"modules"</span>: <span class="literal">false</span>&#125;],</span><br><span class="line">    <span class="comment">// webpack understands the native import syntax, and uses it for tree shaking</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"stage-2"</span>,</span><br><span class="line">    <span class="comment">// Specifies what level of language features to activate.</span></span><br><span class="line">    <span class="comment">// Stage 2 is "draft", 4 is finished, 0 is strawman.</span></span><br><span class="line">    <span class="comment">// See https://tc39.github.io/process-document/</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"react"</span></span><br><span class="line">    <span class="comment">// Transpile React components to JavaScript</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"react-hot-loader/babel"</span></span><br><span class="line">    <span class="comment">// Enables React code to work with HMR.</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code> 的参考配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    <span class="string">'react-hot-loader/patch'</span>,</span><br><span class="line">    <span class="comment">// activate HMR for React</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'webpack-dev-server/client?http://localhost:8080'</span>,</span><br><span class="line">    <span class="comment">// bundle the client for webpack-dev-server</span></span><br><span class="line">    <span class="comment">// and connect to the provided endpoint</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'webpack/hot/only-dev-server'</span>,</span><br><span class="line">    <span class="comment">// bundle the client for hot reloading</span></span><br><span class="line">    <span class="comment">// only- means to only hot reload for successful updates</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">'./index.js'</span></span><br><span class="line">    <span class="comment">// the entry point of our app</span></span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    <span class="comment">// the output bundle</span></span><br><span class="line"></span><br><span class="line">    path: resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line"></span><br><span class="line">    publicPath: <span class="string">'/'</span></span><br><span class="line">    <span class="comment">// necessary for HMR to know where to load the hot update chunks</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  context: resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line"></span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// enable HMR on the server</span></span><br><span class="line"></span><br><span class="line">    contentBase: resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// match the output path</span></span><br><span class="line"></span><br><span class="line">    publicPath: <span class="string">'/'</span></span><br><span class="line">    <span class="comment">// match the output `publicPath`</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'babel-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader?modules'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="comment">// enable HMR globally</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">    <span class="comment">// prints more readable module names in the browser console on HMR updates</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的配置是假定入口文件是 <code>./src/index.js</code>，且需要引入 Loader 来处理 CSS 模块。注意 <code>entry</code> 属性中增加了 <code>react-hot-loader</code> 模块，这是开启 React 组件 HMR 的必要操作。<code>NamedModulesPlugin</code> 是非常有用的 Plugin，它能友好的显示什么模块发生了 HMR。</p><p>再来看 webpack 官方文档给出的入口 JS 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">'react-hot-loader'</span>;</span><br><span class="line"><span class="comment">// AppContainer is a necessary wrapper component for HMR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">Component</span>) =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;AppContainer&gt;</span><br><span class="line">      &lt;Component/&gt;</span><br><span class="line">    &lt;<span class="regexp">/AppContainer&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render(App);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Hot Module Replacement API</span></span><br><span class="line"><span class="regexp">if (module.hot) &#123;</span></span><br><span class="line"><span class="regexp">  module.hot.accept('./</span>components/App<span class="string">', () =&gt; &#123;</span></span><br><span class="line"><span class="string">    const NewApp = require('</span>./components/App<span class="string">').default</span></span><br><span class="line"><span class="string">    render(NewApp)</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>App 组件 <code>App.js</code> 源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/components/App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div className=&#123;styles.app&#125;&gt;</span><br><span class="line">    &lt;h2&gt;Hello, &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><code>App.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ./src/components/App.css</span><br><span class="line"><span class="selector-class">.app</span> &#123;</span><br><span class="line">    <span class="attribute">text-size-adjust</span>: none;</span><br><span class="line">    <span class="attribute">font-family</span>: helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">20px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录下执行 <code>webpack-dev-server</code>，打开 <code>http：//127.0.0.1:8080</code> 查看页面控制台。</p><hr><p>参考资料：</p><ul><li>Webpack 2 - <a href="https://webpack.js.org" target="_blank" rel="noopener">Docs</a></li><li>阮一峰 - <a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="noopener">webpack-demos</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于前端开发者而言，2016 又是一个风不平浪不静的一年。今年新冒出的框架工具，如果不是专职前端或全栈，估计现在和我是差不多的状态，一脸懵逼外加黑人问号脸。为了以后和前端协作时不被鄙视，努力在 2016 年结束前，赶紧先上车，这就是我一个后端开发做前端补习的动机，本文是 Webpack 篇，后续还会更新 Yarn、React、Redux 等。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="Frontend" scheme="https://isudox.com/tags/Frontend/"/>
    
      <category term="Webpack" scheme="https://isudox.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CORS 跨域调试记录</title>
    <link href="https://isudox.com/2016/11/12/cors-in-action/"/>
    <id>https://isudox.com/2016/11/12/cors-in-action/</id>
    <published>2016-11-11T16:31:58.000Z</published>
    <updated>2019-03-26T15:34:13.427Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了篇关于 JSONP 和 CORS 解决跨域请求的博客，在最近和深圳凹凸团队前后端联调时实打实的实战了一把 CORS。还是应了纸上得来终觉浅的老话，因为实际运用中会存在不同的状况，只是看文档理解概念并不能真正成为实战派。</p><a id="more"></a><p>这次联调采用前后端分离的方式，后端由 Spring MVC 提供数据接口，前端通过异步的方式做数据渲染，和以往不同的是，由于前端开发全部交给深圳的凹凸实验室，所以静态文件都跑在独立的一个域名上，就是京东的通天塔项目。因此所有来自前端的请求都成了跨域请求。</p><p>JSONP 确实是通过一种巧妙的伎俩解决了跨域请求被浏览器拒绝的问题，但是它并不能解决 POST 跨域，联调的接口是跨域上传头像，采用 POST 发送 FormData 对象的方式。所以由服务端 CORS 来处理。</p><p>对于服务端，Spring MVC 设置 CORS 很简单，如果 springframework 版本是 4.2 及以上，Spring MVC 可以直接由注解 <code>@CrossOrigin</code> 对标记的控制器方法设置 CORS。例如下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(origins = <span class="string">"http://localhost:9000"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/greeting"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Greeting <span class="title">greeting</span><span class="params">(@RequestParam(required=<span class="keyword">false</span>, defaultValue=<span class="string">"World"</span>)</span> String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"==== in greeting ===="</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greeting(counter.incrementAndGet(), String.format(template, name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@CrossOrigin</code> 注解可以通过设置 <code>origins</code>、<code>methods</code>、<code>maxAge</code>、<code>allowHeaders</code>、<code>allowCredentials</code> 等参数来确定 CORS 接受跨域的来源域，请求类型，请求头等。如果 origins 设置为星号，则对所有来源域的请求都允许跨域，methods 设置为 POST 就只允许请求类型为 POST 的跨域请求。</p><p>前端正常发送异步请求，类似如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">formData.append(<span class="string">'avatar'</span>, <span class="string">'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEX/TQBcNTh/AAAAAXRSTlPM0jRW/QAAAApJREFUeJxjYgAAAAYAAzY3fKgAAAAASUVORK5CYII='</span>);</span><br><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'POST'</span>, <span class="string">'//xxx.jd.com/xxx/xxx'</span>);</span><br><span class="line">req.send(fromData);</span><br></pre></td></tr></table></figure><p>但是结果并不如人意，返回码 302，请求被强制跳转京东的统一登录，这就是一个问题点，因为上传头像要求登录状态，所以浏览器请求时必须带上本地的 cookies，如果是 JSONP 的方式，它默认会传递 cookies。所以需要将 XMLHttpRequest 的凭证信息标识位设为 true：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这里有一点需要留意，如果请求带上了 cookies 那么服务端 CORS 的 origins 不能是 <code>*</code> 号，必须明确指定允许的来源 origin。再次联调测试，跨域还是失败了，看服务端日志发现，请求根本没有进入到 Controller 层，在登录拦截器里就被拒绝了。这是另外一个问题，因为 Spring MVC 设置了 interceptors，符合规则的请求都会被 interceptor 拦截，要么排除该跨域请求，但这是不可取，因为必须是登录用户才能进行的操作。所以需要在拦截器的 <code>preHandle()</code> 方法里进行处理，把来源域的加入到响应头的 <code>Access-Control-Allow-Origin</code> 字段中，同时设置 <code>Access-Control-Allow-Headers</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span></span>&#123;</span><br><span class="line">  <span class="comment">// before the actual handler will be executed</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            response.addHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://h5.m.jd.com"</span>);</span><br><span class="line">            response.addHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET, PUT, POST, DELETE, OPTIONS"</span>);</span><br><span class="line">            response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type, Authorization, X-Requested-With, isAjaxRequest"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>心想这次总该 OK 了吧，还是没调通，我摔！但是这次是有进步的，因为请求进到 Controller 的方法里，执行完了头像上传，只是浏览器的到的响应体为空，打开浏览器的控制台看到一段错误信息：</p><blockquote><p>XMLHttpRequest cannot load <a href="http://xxxp.jd.com/xxx/xxx" target="_blank" rel="noopener">http://xxxp.jd.com/xxx/xxx</a>. Credentials flag is ‘true’, but the ‘Access-Control-Allow-Credentials’ header is ‘’. It must be ‘true’ to allow credentials. Origin ‘<a href="http://h5.m.jd.com&#39;" target="_blank" rel="noopener">http://h5.m.jd.com&#39;</a> is therefore not allowed access.</p></blockquote><p>这是第三个问题，POST 请求是标记了凭证信息标识位，但是服务端回传的响应头的 <code>Access-Control-Allow-Credentials</code> 字段却是空，而不是 <code>true</code>，解决办法显而易见了，设置 <code>HttpServletResponse</code> 响应字段为 <code>true</code> 即可：</p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span><span class="function"><span class="params">    HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>{        response.addHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);                <span class="keyword">return</span> <span class="keyword">true</span>;}</code></pre><p>这样处理后，浏览器就收到的 Controller 层方法返回的 JSON 结果。</p><p>以上就是这次由服务端 CORS 实现的跨域请求的调试过程。其实从结果看真的很简单，只是有些问题如果实际开发中没有遇到，很容易疏漏，仅仅是看文档学怎么用还是不够的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了篇关于 JSONP 和 CORS 解决跨域请求的博客，在最近和深圳凹凸团队前后端联调时实打实的实战了一把 CORS。还是应了纸上得来终觉浅的老话，因为实际运用中会存在不同的状况，只是看文档理解概念并不能真正成为实战派。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="https://isudox.com/categories/Coding/"/>
    
    
      <category term="HTTP" scheme="https://isudox.com/tags/HTTP/"/>
    
      <category term="SpringMVC" scheme="https://isudox.com/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
